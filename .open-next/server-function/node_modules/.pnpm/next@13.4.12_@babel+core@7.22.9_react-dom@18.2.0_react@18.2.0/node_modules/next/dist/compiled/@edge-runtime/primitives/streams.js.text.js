module.exports = "\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/primitives/streams.js\nvar streams_exports = {};\n__export(streams_exports, {\n  ReadableStream: () => ReadableStream,\n  ReadableStreamBYOBReader: () => ReadableStreamBYOBReader,\n  ReadableStreamDefaultReader: () => ReadableStreamDefaultReader,\n  TransformStream: () => TransformStream,\n  WritableStream: () => WritableStream,\n  WritableStreamDefaultWriter: () => WritableStreamDefaultWriter\n});\nmodule.exports = __toCommonJS(streams_exports);\n\n// ../../node_modules/.pnpm/web-streams-polyfill@4.0.0-beta.3/node_modules/web-streams-polyfill/dist/ponyfill.mjs\nvar e = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? Symbol : (e2) => `Symbol(${e2})`;\nfunction t() {\n}\n__name(t, \"t\");\nfunction r(e2) {\n  return \"object\" == typeof e2 && null !== e2 || \"function\" == typeof e2;\n}\n__name(r, \"r\");\nvar o = t;\nfunction n(e2, t2) {\n  try {\n    Object.defineProperty(e2, \"name\", { value: t2, configurable: true });\n  } catch (e3) {\n  }\n}\n__name(n, \"n\");\nvar a = Promise;\nvar i = Promise.prototype.then;\nvar l = Promise.resolve.bind(a);\nvar s = Promise.reject.bind(a);\nfunction u(e2) {\n  return new a(e2);\n}\n__name(u, \"u\");\nfunction c(e2) {\n  return l(e2);\n}\n__name(c, \"c\");\nfunction d(e2) {\n  return s(e2);\n}\n__name(d, \"d\");\nfunction f(e2, t2, r2) {\n  return i.call(e2, t2, r2);\n}\n__name(f, \"f\");\nfunction b(e2, t2, r2) {\n  f(f(e2, t2, r2), void 0, o);\n}\n__name(b, \"b\");\nfunction h(e2, t2) {\n  b(e2, t2);\n}\n__name(h, \"h\");\nfunction _(e2, t2) {\n  b(e2, void 0, t2);\n}\n__name(_, \"_\");\nfunction p(e2, t2, r2) {\n  return f(e2, t2, r2);\n}\n__name(p, \"p\");\nfunction m(e2) {\n  f(e2, void 0, o);\n}\n__name(m, \"m\");\nvar y = /* @__PURE__ */ __name((e2) => {\n  if (\"function\" == typeof queueMicrotask)\n    y = queueMicrotask;\n  else {\n    const e3 = c(void 0);\n    y = /* @__PURE__ */ __name((t2) => f(e3, t2), \"y\");\n  }\n  return y(e2);\n}, \"y\");\nfunction g(e2, t2, r2) {\n  if (\"function\" != typeof e2)\n    throw new TypeError(\"Argument is not a function\");\n  return Function.prototype.apply.call(e2, t2, r2);\n}\n__name(g, \"g\");\nfunction w(e2, t2, r2) {\n  try {\n    return c(g(e2, t2, r2));\n  } catch (e3) {\n    return d(e3);\n  }\n}\n__name(w, \"w\");\nvar S = class {\n  constructor() {\n    this._cursor = 0, this._size = 0, this._front = { _elements: [], _next: void 0 }, this._back = this._front, this._cursor = 0, this._size = 0;\n  }\n  get length() {\n    return this._size;\n  }\n  push(e2) {\n    const t2 = this._back;\n    let r2 = t2;\n    16383 === t2._elements.length && (r2 = { _elements: [], _next: void 0 }), t2._elements.push(e2), r2 !== t2 && (this._back = r2, t2._next = r2), ++this._size;\n  }\n  shift() {\n    const e2 = this._front;\n    let t2 = e2;\n    const r2 = this._cursor;\n    let o2 = r2 + 1;\n    const n2 = e2._elements, a2 = n2[r2];\n    return 16384 === o2 && (t2 = e2._next, o2 = 0), --this._size, this._cursor = o2, e2 !== t2 && (this._front = t2), n2[r2] = void 0, a2;\n  }\n  forEach(e2) {\n    let t2 = this._cursor, r2 = this._front, o2 = r2._elements;\n    for (; !(t2 === o2.length && void 0 === r2._next || t2 === o2.length && (r2 = r2._next, o2 = r2._elements, t2 = 0, 0 === o2.length)); )\n      e2(o2[t2]), ++t2;\n  }\n  peek() {\n    const e2 = this._front, t2 = this._cursor;\n    return e2._elements[t2];\n  }\n};\n__name(S, \"S\");\nvar v = e(\"[[AbortSteps]]\");\nvar R = e(\"[[ErrorSteps]]\");\nvar T = e(\"[[CancelSteps]]\");\nvar q = e(\"[[PullSteps]]\");\nvar C = e(\"[[ReleaseSteps]]\");\nfunction E(e2, t2) {\n  e2._ownerReadableStream = t2, t2._reader = e2, \"readable\" === t2._state ? O(e2) : \"closed\" === t2._state ? function(e3) {\n    O(e3), j(e3);\n  }(e2) : B(e2, t2._storedError);\n}\n__name(E, \"E\");\nfunction P(e2, t2) {\n  return Gt(e2._ownerReadableStream, t2);\n}\n__name(P, \"P\");\nfunction W(e2) {\n  const t2 = e2._ownerReadableStream;\n  \"readable\" === t2._state ? A(e2, new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\")) : function(e3, t3) {\n    B(e3, t3);\n  }(e2, new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\")), t2._readableStreamController[C](), t2._reader = void 0, e2._ownerReadableStream = void 0;\n}\n__name(W, \"W\");\nfunction k(e2) {\n  return new TypeError(\"Cannot \" + e2 + \" a stream using a released reader\");\n}\n__name(k, \"k\");\nfunction O(e2) {\n  e2._closedPromise = u((t2, r2) => {\n    e2._closedPromise_resolve = t2, e2._closedPromise_reject = r2;\n  });\n}\n__name(O, \"O\");\nfunction B(e2, t2) {\n  O(e2), A(e2, t2);\n}\n__name(B, \"B\");\nfunction A(e2, t2) {\n  void 0 !== e2._closedPromise_reject && (m(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0);\n}\n__name(A, \"A\");\nfunction j(e2) {\n  void 0 !== e2._closedPromise_resolve && (e2._closedPromise_resolve(void 0), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0);\n}\n__name(j, \"j\");\nvar z = Number.isFinite || function(e2) {\n  return \"number\" == typeof e2 && isFinite(e2);\n};\nvar L = Math.trunc || function(e2) {\n  return e2 < 0 ? Math.ceil(e2) : Math.floor(e2);\n};\nfunction F(e2, t2) {\n  if (void 0 !== e2 && (\"object\" != typeof (r2 = e2) && \"function\" != typeof r2))\n    throw new TypeError(`${t2} is not an object.`);\n  var r2;\n}\n__name(F, \"F\");\nfunction I(e2, t2) {\n  if (\"function\" != typeof e2)\n    throw new TypeError(`${t2} is not a function.`);\n}\n__name(I, \"I\");\nfunction D(e2, t2) {\n  if (!function(e3) {\n    return \"object\" == typeof e3 && null !== e3 || \"function\" == typeof e3;\n  }(e2))\n    throw new TypeError(`${t2} is not an object.`);\n}\n__name(D, \"D\");\nfunction $(e2, t2, r2) {\n  if (void 0 === e2)\n    throw new TypeError(`Parameter ${t2} is required in '${r2}'.`);\n}\n__name($, \"$\");\nfunction M(e2, t2, r2) {\n  if (void 0 === e2)\n    throw new TypeError(`${t2} is required in '${r2}'.`);\n}\n__name(M, \"M\");\nfunction Y(e2) {\n  return Number(e2);\n}\n__name(Y, \"Y\");\nfunction Q(e2) {\n  return 0 === e2 ? 0 : e2;\n}\n__name(Q, \"Q\");\nfunction N(e2, t2) {\n  const r2 = Number.MAX_SAFE_INTEGER;\n  let o2 = Number(e2);\n  if (o2 = Q(o2), !z(o2))\n    throw new TypeError(`${t2} is not a finite number`);\n  if (o2 = function(e3) {\n    return Q(L(e3));\n  }(o2), o2 < 0 || o2 > r2)\n    throw new TypeError(`${t2} is outside the accepted range of 0 to ${r2}, inclusive`);\n  return z(o2) && 0 !== o2 ? o2 : 0;\n}\n__name(N, \"N\");\nfunction H(e2) {\n  if (!r(e2))\n    return false;\n  if (\"function\" != typeof e2.getReader)\n    return false;\n  try {\n    return \"boolean\" == typeof e2.locked;\n  } catch (e3) {\n    return false;\n  }\n}\n__name(H, \"H\");\nfunction x(e2) {\n  if (!r(e2))\n    return false;\n  if (\"function\" != typeof e2.getWriter)\n    return false;\n  try {\n    return \"boolean\" == typeof e2.locked;\n  } catch (e3) {\n    return false;\n  }\n}\n__name(x, \"x\");\nfunction V(e2, t2) {\n  if (!Vt(e2))\n    throw new TypeError(`${t2} is not a ReadableStream.`);\n}\n__name(V, \"V\");\nfunction U(e2, t2) {\n  e2._reader._readRequests.push(t2);\n}\n__name(U, \"U\");\nfunction G(e2, t2, r2) {\n  const o2 = e2._reader._readRequests.shift();\n  r2 ? o2._closeSteps() : o2._chunkSteps(t2);\n}\n__name(G, \"G\");\nfunction X(e2) {\n  return e2._reader._readRequests.length;\n}\n__name(X, \"X\");\nfunction J(e2) {\n  const t2 = e2._reader;\n  return void 0 !== t2 && !!K(t2);\n}\n__name(J, \"J\");\nvar ReadableStreamDefaultReader = class {\n  constructor(e2) {\n    if ($(e2, 1, \"ReadableStreamDefaultReader\"), V(e2, \"First parameter\"), Ut(e2))\n      throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n    E(this, e2), this._readRequests = new S();\n  }\n  get closed() {\n    return K(this) ? this._closedPromise : d(ee(\"closed\"));\n  }\n  cancel(e2) {\n    return K(this) ? void 0 === this._ownerReadableStream ? d(k(\"cancel\")) : P(this, e2) : d(ee(\"cancel\"));\n  }\n  read() {\n    if (!K(this))\n      return d(ee(\"read\"));\n    if (void 0 === this._ownerReadableStream)\n      return d(k(\"read from\"));\n    let e2, t2;\n    const r2 = u((r3, o2) => {\n      e2 = r3, t2 = o2;\n    });\n    return function(e3, t3) {\n      const r3 = e3._ownerReadableStream;\n      r3._disturbed = true, \"closed\" === r3._state ? t3._closeSteps() : \"errored\" === r3._state ? t3._errorSteps(r3._storedError) : r3._readableStreamController[q](t3);\n    }(this, { _chunkSteps: (t3) => e2({ value: t3, done: false }), _closeSteps: () => e2({ value: void 0, done: true }), _errorSteps: (e3) => t2(e3) }), r2;\n  }\n  releaseLock() {\n    if (!K(this))\n      throw ee(\"releaseLock\");\n    void 0 !== this._ownerReadableStream && function(e2) {\n      W(e2);\n      const t2 = new TypeError(\"Reader was released\");\n      Z(e2, t2);\n    }(this);\n  }\n};\n__name(ReadableStreamDefaultReader, \"ReadableStreamDefaultReader\");\nfunction K(e2) {\n  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, \"_readRequests\") && e2 instanceof ReadableStreamDefaultReader);\n}\n__name(K, \"K\");\nfunction Z(e2, t2) {\n  const r2 = e2._readRequests;\n  e2._readRequests = new S(), r2.forEach((e3) => {\n    e3._errorSteps(t2);\n  });\n}\n__name(Z, \"Z\");\nfunction ee(e2) {\n  return new TypeError(`ReadableStreamDefaultReader.prototype.${e2} can only be used on a ReadableStreamDefaultReader`);\n}\n__name(ee, \"ee\");\nObject.defineProperties(ReadableStreamDefaultReader.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), n(ReadableStreamDefaultReader.prototype.cancel, \"cancel\"), n(ReadableStreamDefaultReader.prototype.read, \"read\"), n(ReadableStreamDefaultReader.prototype.releaseLock, \"releaseLock\"), \"symbol\" == typeof e.toStringTag && Object.defineProperty(ReadableStreamDefaultReader.prototype, e.toStringTag, { value: \"ReadableStreamDefaultReader\", configurable: true });\nvar te = class {\n  constructor(e2, t2) {\n    this._ongoingPromise = void 0, this._isFinished = false, this._reader = e2, this._preventCancel = t2;\n  }\n  next() {\n    const e2 = /* @__PURE__ */ __name(() => this._nextSteps(), \"e\");\n    return this._ongoingPromise = this._ongoingPromise ? p(this._ongoingPromise, e2, e2) : e2(), this._ongoingPromise;\n  }\n  return(e2) {\n    const t2 = /* @__PURE__ */ __name(() => this._returnSteps(e2), \"t\");\n    return this._ongoingPromise ? p(this._ongoingPromise, t2, t2) : t2();\n  }\n  _nextSteps() {\n    if (this._isFinished)\n      return Promise.resolve({ value: void 0, done: true });\n    const e2 = this._reader;\n    return void 0 === e2 ? d(k(\"iterate\")) : f(e2.read(), (e3) => {\n      var t2;\n      return this._ongoingPromise = void 0, e3.done && (this._isFinished = true, null === (t2 = this._reader) || void 0 === t2 || t2.releaseLock(), this._reader = void 0), e3;\n    }, (e3) => {\n      var t2;\n      throw this._ongoingPromise = void 0, this._isFinished = true, null === (t2 = this._reader) || void 0 === t2 || t2.releaseLock(), this._reader = void 0, e3;\n    });\n  }\n  _returnSteps(e2) {\n    if (this._isFinished)\n      return Promise.resolve({ value: e2, done: true });\n    this._isFinished = true;\n    const t2 = this._reader;\n    if (void 0 === t2)\n      return d(k(\"finish iterating\"));\n    if (this._reader = void 0, !this._preventCancel) {\n      const r2 = t2.cancel(e2);\n      return t2.releaseLock(), p(r2, () => ({ value: e2, done: true }));\n    }\n    return t2.releaseLock(), c({ value: e2, done: true });\n  }\n};\n__name(te, \"te\");\nvar re = { next() {\n  return oe(this) ? this._asyncIteratorImpl.next() : d(ne(\"next\"));\n}, return(e2) {\n  return oe(this) ? this._asyncIteratorImpl.return(e2) : d(ne(\"return\"));\n} };\nfunction oe(e2) {\n  if (!r(e2))\n    return false;\n  if (!Object.prototype.hasOwnProperty.call(e2, \"_asyncIteratorImpl\"))\n    return false;\n  try {\n    return e2._asyncIteratorImpl instanceof te;\n  } catch (e3) {\n    return false;\n  }\n}\n__name(oe, \"oe\");\nfunction ne(e2) {\n  return new TypeError(`ReadableStreamAsyncIterator.${e2} can only be used on a ReadableSteamAsyncIterator`);\n}\n__name(ne, \"ne\");\n\"symbol\" == typeof e.asyncIterator && Object.defineProperty(re, e.asyncIterator, { value() {\n  return this;\n}, writable: true, configurable: true });\nvar ae = Number.isNaN || function(e2) {\n  return e2 != e2;\n};\nfunction ie(e2, t2, r2, o2, n2) {\n  new Uint8Array(e2).set(new Uint8Array(r2, o2, n2), t2);\n}\n__name(ie, \"ie\");\nfunction le(e2) {\n  const t2 = function(e3, t3, r2) {\n    if (e3.slice)\n      return e3.slice(t3, r2);\n    const o2 = r2 - t3, n2 = new ArrayBuffer(o2);\n    return ie(n2, 0, e3, t3, o2), n2;\n  }(e2.buffer, e2.byteOffset, e2.byteOffset + e2.byteLength);\n  return new Uint8Array(t2);\n}\n__name(le, \"le\");\nfunction se(e2) {\n  const t2 = e2._queue.shift();\n  return e2._queueTotalSize -= t2.size, e2._queueTotalSize < 0 && (e2._queueTotalSize = 0), t2.value;\n}\n__name(se, \"se\");\nfunction ue(e2, t2, r2) {\n  if (\"number\" != typeof (o2 = r2) || ae(o2) || o2 < 0 || r2 === 1 / 0)\n    throw new RangeError(\"Size must be a finite, non-NaN, non-negative number.\");\n  var o2;\n  e2._queue.push({ value: t2, size: r2 }), e2._queueTotalSize += r2;\n}\n__name(ue, \"ue\");\nfunction ce(e2) {\n  e2._queue = new S(), e2._queueTotalSize = 0;\n}\n__name(ce, \"ce\");\nvar ReadableStreamBYOBRequest = class {\n  constructor() {\n    throw new TypeError(\"Illegal constructor\");\n  }\n  get view() {\n    if (!fe(this))\n      throw Be(\"view\");\n    return this._view;\n  }\n  respond(e2) {\n    if (!fe(this))\n      throw Be(\"respond\");\n    if ($(e2, 1, \"respond\"), e2 = N(e2, \"First parameter\"), void 0 === this._associatedReadableByteStreamController)\n      throw new TypeError(\"This BYOB request has been invalidated\");\n    this._view.buffer, function(e3, t2) {\n      const r2 = e3._pendingPullIntos.peek();\n      if (\"closed\" === e3._controlledReadableByteStream._state) {\n        if (0 !== t2)\n          throw new TypeError(\"bytesWritten must be 0 when calling respond() on a closed stream\");\n      } else {\n        if (0 === t2)\n          throw new TypeError(\"bytesWritten must be greater than 0 when calling respond() on a readable stream\");\n        if (r2.bytesFilled + t2 > r2.byteLength)\n          throw new RangeError(\"bytesWritten out of range\");\n      }\n      r2.buffer = r2.buffer, qe(e3, t2);\n    }(this._associatedReadableByteStreamController, e2);\n  }\n  respondWithNewView(e2) {\n    if (!fe(this))\n      throw Be(\"respondWithNewView\");\n    if ($(e2, 1, \"respondWithNewView\"), !ArrayBuffer.isView(e2))\n      throw new TypeError(\"You can only respond with array buffer views\");\n    if (void 0 === this._associatedReadableByteStreamController)\n      throw new TypeError(\"This BYOB request has been invalidated\");\n    e2.buffer, function(e3, t2) {\n      const r2 = e3._pendingPullIntos.peek();\n      if (\"closed\" === e3._controlledReadableByteStream._state) {\n        if (0 !== t2.byteLength)\n          throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\");\n      } else if (0 === t2.byteLength)\n        throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n      if (r2.byteOffset + r2.bytesFilled !== t2.byteOffset)\n        throw new RangeError(\"The region specified by view does not match byobRequest\");\n      if (r2.bufferByteLength !== t2.buffer.byteLength)\n        throw new RangeError(\"The buffer of view has different capacity than byobRequest\");\n      if (r2.bytesFilled + t2.byteLength > r2.byteLength)\n        throw new RangeError(\"The region specified by view is larger than byobRequest\");\n      const o2 = t2.byteLength;\n      r2.buffer = t2.buffer, qe(e3, o2);\n    }(this._associatedReadableByteStreamController, e2);\n  }\n};\n__name(ReadableStreamBYOBRequest, \"ReadableStreamBYOBRequest\");\nObject.defineProperties(ReadableStreamBYOBRequest.prototype, { respond: { enumerable: true }, respondWithNewView: { enumerable: true }, view: { enumerable: true } }), n(ReadableStreamBYOBRequest.prototype.respond, \"respond\"), n(ReadableStreamBYOBRequest.prototype.respondWithNewView, \"respondWithNewView\"), \"symbol\" == typeof e.toStringTag && Object.defineProperty(ReadableStreamBYOBRequest.prototype, e.toStringTag, { value: \"ReadableStreamBYOBRequest\", configurable: true });\nvar ReadableByteStreamController = class {\n  constructor() {\n    throw new TypeError(\"Illegal constructor\");\n  }\n  get byobRequest() {\n    if (!de(this))\n      throw Ae(\"byobRequest\");\n    return function(e2) {\n      if (null === e2._byobRequest && e2._pendingPullIntos.length > 0) {\n        const t2 = e2._pendingPullIntos.peek(), r2 = new Uint8Array(t2.buffer, t2.byteOffset + t2.bytesFilled, t2.byteLength - t2.bytesFilled), o2 = Object.create(ReadableStreamBYOBRequest.prototype);\n        !function(e3, t3, r3) {\n          e3._associatedReadableByteStreamController = t3, e3._view = r3;\n        }(o2, e2, r2), e2._byobRequest = o2;\n      }\n      return e2._byobRequest;\n    }(this);\n  }\n  get desiredSize() {\n    if (!de(this))\n      throw Ae(\"desiredSize\");\n    return ke(this);\n  }\n  close() {\n    if (!de(this))\n      throw Ae(\"close\");\n    if (this._closeRequested)\n      throw new TypeError(\"The stream has already been closed; do not close it again!\");\n    const e2 = this._controlledReadableByteStream._state;\n    if (\"readable\" !== e2)\n      throw new TypeError(`The stream (in ${e2} state) is not in the readable state and cannot be closed`);\n    !function(e3) {\n      const t2 = e3._controlledReadableByteStream;\n      if (e3._closeRequested || \"readable\" !== t2._state)\n        return;\n      if (e3._queueTotalSize > 0)\n        return void (e3._closeRequested = true);\n      if (e3._pendingPullIntos.length > 0) {\n        if (e3._pendingPullIntos.peek().bytesFilled > 0) {\n          const t3 = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n          throw Pe(e3, t3), t3;\n        }\n      }\n      Ee(e3), Xt(t2);\n    }(this);\n  }\n  enqueue(e2) {\n    if (!de(this))\n      throw Ae(\"enqueue\");\n    if ($(e2, 1, \"enqueue\"), !ArrayBuffer.isView(e2))\n      throw new TypeError(\"chunk must be an array buffer view\");\n    if (0 === e2.byteLength)\n      throw new TypeError(\"chunk must have non-zero byteLength\");\n    if (0 === e2.buffer.byteLength)\n      throw new TypeError(\"chunk's buffer must have non-zero byteLength\");\n    if (this._closeRequested)\n      throw new TypeError(\"stream is closed or draining\");\n    const t2 = this._controlledReadableByteStream._state;\n    if (\"readable\" !== t2)\n      throw new TypeError(`The stream (in ${t2} state) is not in the readable state and cannot be enqueued to`);\n    !function(e3, t3) {\n      const r2 = e3._controlledReadableByteStream;\n      if (e3._closeRequested || \"readable\" !== r2._state)\n        return;\n      const o2 = t3.buffer, n2 = t3.byteOffset, a2 = t3.byteLength, i2 = o2;\n      if (e3._pendingPullIntos.length > 0) {\n        const t4 = e3._pendingPullIntos.peek();\n        t4.buffer, 0, Re(e3), t4.buffer = t4.buffer, \"none\" === t4.readerType && ge(e3, t4);\n      }\n      if (J(r2))\n        if (function(e4) {\n          const t4 = e4._controlledReadableByteStream._reader;\n          for (; t4._readRequests.length > 0; ) {\n            if (0 === e4._queueTotalSize)\n              return;\n            We(e4, t4._readRequests.shift());\n          }\n        }(e3), 0 === X(r2))\n          me(e3, i2, n2, a2);\n        else {\n          e3._pendingPullIntos.length > 0 && Ce(e3);\n          G(r2, new Uint8Array(i2, n2, a2), false);\n        }\n      else\n        Le(r2) ? (me(e3, i2, n2, a2), Te(e3)) : me(e3, i2, n2, a2);\n      be(e3);\n    }(this, e2);\n  }\n  error(e2) {\n    if (!de(this))\n      throw Ae(\"error\");\n    Pe(this, e2);\n  }\n  [T](e2) {\n    he(this), ce(this);\n    const t2 = this._cancelAlgorithm(e2);\n    return Ee(this), t2;\n  }\n  [q](e2) {\n    const t2 = this._controlledReadableByteStream;\n    if (this._queueTotalSize > 0)\n      return void We(this, e2);\n    const r2 = this._autoAllocateChunkSize;\n    if (void 0 !== r2) {\n      let t3;\n      try {\n        t3 = new ArrayBuffer(r2);\n      } catch (t4) {\n        return void e2._errorSteps(t4);\n      }\n      const o2 = { buffer: t3, bufferByteLength: r2, byteOffset: 0, byteLength: r2, bytesFilled: 0, elementSize: 1, viewConstructor: Uint8Array, readerType: \"default\" };\n      this._pendingPullIntos.push(o2);\n    }\n    U(t2, e2), be(this);\n  }\n  [C]() {\n    if (this._pendingPullIntos.length > 0) {\n      const e2 = this._pendingPullIntos.peek();\n      e2.readerType = \"none\", this._pendingPullIntos = new S(), this._pendingPullIntos.push(e2);\n    }\n  }\n};\n__name(ReadableByteStreamController, \"ReadableByteStreamController\");\nfunction de(e2) {\n  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, \"_controlledReadableByteStream\") && e2 instanceof ReadableByteStreamController);\n}\n__name(de, \"de\");\nfunction fe(e2) {\n  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, \"_associatedReadableByteStreamController\") && e2 instanceof ReadableStreamBYOBRequest);\n}\n__name(fe, \"fe\");\nfunction be(e2) {\n  const t2 = function(e3) {\n    const t3 = e3._controlledReadableByteStream;\n    if (\"readable\" !== t3._state)\n      return false;\n    if (e3._closeRequested)\n      return false;\n    if (!e3._started)\n      return false;\n    if (J(t3) && X(t3) > 0)\n      return true;\n    if (Le(t3) && ze(t3) > 0)\n      return true;\n    if (ke(e3) > 0)\n      return true;\n    return false;\n  }(e2);\n  if (!t2)\n    return;\n  if (e2._pulling)\n    return void (e2._pullAgain = true);\n  e2._pulling = true;\n  b(e2._pullAlgorithm(), () => (e2._pulling = false, e2._pullAgain && (e2._pullAgain = false, be(e2)), null), (t3) => (Pe(e2, t3), null));\n}\n__name(be, \"be\");\nfunction he(e2) {\n  Re(e2), e2._pendingPullIntos = new S();\n}\n__name(he, \"he\");\nfunction _e(e2, t2) {\n  let r2 = false;\n  \"closed\" === e2._state && (r2 = true);\n  const o2 = pe(t2);\n  \"default\" === t2.readerType ? G(e2, o2, r2) : function(e3, t3, r3) {\n    const o3 = e3._reader._readIntoRequests.shift();\n    r3 ? o3._closeSteps(t3) : o3._chunkSteps(t3);\n  }(e2, o2, r2);\n}\n__name(_e, \"_e\");\nfunction pe(e2) {\n  const t2 = e2.bytesFilled, r2 = e2.elementSize;\n  return new e2.viewConstructor(e2.buffer, e2.byteOffset, t2 / r2);\n}\n__name(pe, \"pe\");\nfunction me(e2, t2, r2, o2) {\n  e2._queue.push({ buffer: t2, byteOffset: r2, byteLength: o2 }), e2._queueTotalSize += o2;\n}\n__name(me, \"me\");\nfunction ye(e2, t2, r2, o2) {\n  let n2;\n  try {\n    n2 = t2.slice(r2, r2 + o2);\n  } catch (t3) {\n    throw Pe(e2, t3), t3;\n  }\n  me(e2, n2, 0, o2);\n}\n__name(ye, \"ye\");\nfunction ge(e2, t2) {\n  t2.bytesFilled > 0 && ye(e2, t2.buffer, t2.byteOffset, t2.bytesFilled), Ce(e2);\n}\n__name(ge, \"ge\");\nfunction we(e2, t2) {\n  const r2 = t2.elementSize, o2 = t2.bytesFilled - t2.bytesFilled % r2, n2 = Math.min(e2._queueTotalSize, t2.byteLength - t2.bytesFilled), a2 = t2.bytesFilled + n2, i2 = a2 - a2 % r2;\n  let l2 = n2, s2 = false;\n  i2 > o2 && (l2 = i2 - t2.bytesFilled, s2 = true);\n  const u2 = e2._queue;\n  for (; l2 > 0; ) {\n    const r3 = u2.peek(), o3 = Math.min(l2, r3.byteLength), n3 = t2.byteOffset + t2.bytesFilled;\n    ie(t2.buffer, n3, r3.buffer, r3.byteOffset, o3), r3.byteLength === o3 ? u2.shift() : (r3.byteOffset += o3, r3.byteLength -= o3), e2._queueTotalSize -= o3, Se(e2, o3, t2), l2 -= o3;\n  }\n  return s2;\n}\n__name(we, \"we\");\nfunction Se(e2, t2, r2) {\n  r2.bytesFilled += t2;\n}\n__name(Se, \"Se\");\nfunction ve(e2) {\n  0 === e2._queueTotalSize && e2._closeRequested ? (Ee(e2), Xt(e2._controlledReadableByteStream)) : be(e2);\n}\n__name(ve, \"ve\");\nfunction Re(e2) {\n  null !== e2._byobRequest && (e2._byobRequest._associatedReadableByteStreamController = void 0, e2._byobRequest._view = null, e2._byobRequest = null);\n}\n__name(Re, \"Re\");\nfunction Te(e2) {\n  for (; e2._pendingPullIntos.length > 0; ) {\n    if (0 === e2._queueTotalSize)\n      return;\n    const t2 = e2._pendingPullIntos.peek();\n    we(e2, t2) && (Ce(e2), _e(e2._controlledReadableByteStream, t2));\n  }\n}\n__name(Te, \"Te\");\nfunction qe(e2, t2) {\n  const r2 = e2._pendingPullIntos.peek();\n  Re(e2);\n  \"closed\" === e2._controlledReadableByteStream._state ? function(e3, t3) {\n    \"none\" === t3.readerType && Ce(e3);\n    const r3 = e3._controlledReadableByteStream;\n    if (Le(r3))\n      for (; ze(r3) > 0; )\n        _e(r3, Ce(e3));\n  }(e2, r2) : function(e3, t3, r3) {\n    if (Se(0, t3, r3), \"none\" === r3.readerType)\n      return ge(e3, r3), void Te(e3);\n    if (r3.bytesFilled < r3.elementSize)\n      return;\n    Ce(e3);\n    const o2 = r3.bytesFilled % r3.elementSize;\n    if (o2 > 0) {\n      const t4 = r3.byteOffset + r3.bytesFilled;\n      ye(e3, r3.buffer, t4 - o2, o2);\n    }\n    r3.bytesFilled -= o2, _e(e3._controlledReadableByteStream, r3), Te(e3);\n  }(e2, t2, r2), be(e2);\n}\n__name(qe, \"qe\");\nfunction Ce(e2) {\n  return e2._pendingPullIntos.shift();\n}\n__name(Ce, \"Ce\");\nfunction Ee(e2) {\n  e2._pullAlgorithm = void 0, e2._cancelAlgorithm = void 0;\n}\n__name(Ee, \"Ee\");\nfunction Pe(e2, t2) {\n  const r2 = e2._controlledReadableByteStream;\n  \"readable\" === r2._state && (he(e2), ce(e2), Ee(e2), Jt(r2, t2));\n}\n__name(Pe, \"Pe\");\nfunction We(e2, t2) {\n  const r2 = e2._queue.shift();\n  e2._queueTotalSize -= r2.byteLength, ve(e2);\n  const o2 = new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);\n  t2._chunkSteps(o2);\n}\n__name(We, \"We\");\nfunction ke(e2) {\n  const t2 = e2._controlledReadableByteStream._state;\n  return \"errored\" === t2 ? null : \"closed\" === t2 ? 0 : e2._strategyHWM - e2._queueTotalSize;\n}\n__name(ke, \"ke\");\nfunction Oe(e2, t2, r2) {\n  const o2 = Object.create(ReadableByteStreamController.prototype);\n  let n2, a2, i2;\n  n2 = void 0 !== t2.start ? () => t2.start(o2) : () => {\n  }, a2 = void 0 !== t2.pull ? () => t2.pull(o2) : () => c(void 0), i2 = void 0 !== t2.cancel ? (e3) => t2.cancel(e3) : () => c(void 0);\n  const l2 = t2.autoAllocateChunkSize;\n  if (0 === l2)\n    throw new TypeError(\"autoAllocateChunkSize must be greater than 0\");\n  !function(e3, t3, r3, o3, n3, a3, i3) {\n    t3._controlledReadableByteStream = e3, t3._pullAgain = false, t3._pulling = false, t3._byobRequest = null, t3._queue = t3._queueTotalSize = void 0, ce(t3), t3._closeRequested = false, t3._started = false, t3._strategyHWM = a3, t3._pullAlgorithm = o3, t3._cancelAlgorithm = n3, t3._autoAllocateChunkSize = i3, t3._pendingPullIntos = new S(), e3._readableStreamController = t3, b(c(r3()), () => (t3._started = true, be(t3), null), (e4) => (Pe(t3, e4), null));\n  }(e2, o2, n2, a2, i2, r2, l2);\n}\n__name(Oe, \"Oe\");\nfunction Be(e2) {\n  return new TypeError(`ReadableStreamBYOBRequest.prototype.${e2} can only be used on a ReadableStreamBYOBRequest`);\n}\n__name(Be, \"Be\");\nfunction Ae(e2) {\n  return new TypeError(`ReadableByteStreamController.prototype.${e2} can only be used on a ReadableByteStreamController`);\n}\n__name(Ae, \"Ae\");\nfunction je(e2, t2) {\n  e2._reader._readIntoRequests.push(t2);\n}\n__name(je, \"je\");\nfunction ze(e2) {\n  return e2._reader._readIntoRequests.length;\n}\n__name(ze, \"ze\");\nfunction Le(e2) {\n  const t2 = e2._reader;\n  return void 0 !== t2 && !!Fe(t2);\n}\n__name(Le, \"Le\");\nObject.defineProperties(ReadableByteStreamController.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, byobRequest: { enumerable: true }, desiredSize: { enumerable: true } }), n(ReadableByteStreamController.prototype.close, \"close\"), n(ReadableByteStreamController.prototype.enqueue, \"enqueue\"), n(ReadableByteStreamController.prototype.error, \"error\"), \"symbol\" == typeof e.toStringTag && Object.defineProperty(ReadableByteStreamController.prototype, e.toStringTag, { value: \"ReadableByteStreamController\", configurable: true });\nvar ReadableStreamBYOBReader = class {\n  constructor(e2) {\n    if ($(e2, 1, \"ReadableStreamBYOBReader\"), V(e2, \"First parameter\"), Ut(e2))\n      throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n    if (!de(e2._readableStreamController))\n      throw new TypeError(\"Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source\");\n    E(this, e2), this._readIntoRequests = new S();\n  }\n  get closed() {\n    return Fe(this) ? this._closedPromise : d(De(\"closed\"));\n  }\n  cancel(e2) {\n    return Fe(this) ? void 0 === this._ownerReadableStream ? d(k(\"cancel\")) : P(this, e2) : d(De(\"cancel\"));\n  }\n  read(e2) {\n    if (!Fe(this))\n      return d(De(\"read\"));\n    if (!ArrayBuffer.isView(e2))\n      return d(new TypeError(\"view must be an array buffer view\"));\n    if (0 === e2.byteLength)\n      return d(new TypeError(\"view must have non-zero byteLength\"));\n    if (0 === e2.buffer.byteLength)\n      return d(new TypeError(\"view's buffer must have non-zero byteLength\"));\n    if (e2.buffer, void 0 === this._ownerReadableStream)\n      return d(k(\"read from\"));\n    let t2, r2;\n    const o2 = u((e3, o3) => {\n      t2 = e3, r2 = o3;\n    });\n    return function(e3, t3, r3) {\n      const o3 = e3._ownerReadableStream;\n      o3._disturbed = true, \"errored\" === o3._state ? r3._errorSteps(o3._storedError) : function(e4, t4, r4) {\n        const o4 = e4._controlledReadableByteStream;\n        let n2 = 1;\n        t4.constructor !== DataView && (n2 = t4.constructor.BYTES_PER_ELEMENT);\n        const a2 = t4.constructor, i2 = t4.buffer, l2 = { buffer: i2, bufferByteLength: i2.byteLength, byteOffset: t4.byteOffset, byteLength: t4.byteLength, bytesFilled: 0, elementSize: n2, viewConstructor: a2, readerType: \"byob\" };\n        if (e4._pendingPullIntos.length > 0)\n          return e4._pendingPullIntos.push(l2), void je(o4, r4);\n        if (\"closed\" !== o4._state) {\n          if (e4._queueTotalSize > 0) {\n            if (we(e4, l2)) {\n              const t5 = pe(l2);\n              return ve(e4), void r4._chunkSteps(t5);\n            }\n            if (e4._closeRequested) {\n              const t5 = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n              return Pe(e4, t5), void r4._errorSteps(t5);\n            }\n          }\n          e4._pendingPullIntos.push(l2), je(o4, r4), be(e4);\n        } else {\n          const e5 = new a2(l2.buffer, l2.byteOffset, 0);\n          r4._closeSteps(e5);\n        }\n      }(o3._readableStreamController, t3, r3);\n    }(this, e2, { _chunkSteps: (e3) => t2({ value: e3, done: false }), _closeSteps: (e3) => t2({ value: e3, done: true }), _errorSteps: (e3) => r2(e3) }), o2;\n  }\n  releaseLock() {\n    if (!Fe(this))\n      throw De(\"releaseLock\");\n    void 0 !== this._ownerReadableStream && function(e2) {\n      W(e2);\n      const t2 = new TypeError(\"Reader was released\");\n      Ie(e2, t2);\n    }(this);\n  }\n};\n__name(ReadableStreamBYOBReader, \"ReadableStreamBYOBReader\");\nfunction Fe(e2) {\n  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, \"_readIntoRequests\") && e2 instanceof ReadableStreamBYOBReader);\n}\n__name(Fe, \"Fe\");\nfunction Ie(e2, t2) {\n  const r2 = e2._readIntoRequests;\n  e2._readIntoRequests = new S(), r2.forEach((e3) => {\n    e3._errorSteps(t2);\n  });\n}\n__name(Ie, \"Ie\");\nfunction De(e2) {\n  return new TypeError(`ReadableStreamBYOBReader.prototype.${e2} can only be used on a ReadableStreamBYOBReader`);\n}\n__name(De, \"De\");\nfunction $e(e2, t2) {\n  const { highWaterMark: r2 } = e2;\n  if (void 0 === r2)\n    return t2;\n  if (ae(r2) || r2 < 0)\n    throw new RangeError(\"Invalid highWaterMark\");\n  return r2;\n}\n__name($e, \"$e\");\nfunction Me(e2) {\n  const { size: t2 } = e2;\n  return t2 || (() => 1);\n}\n__name(Me, \"Me\");\nfunction Ye(e2, t2) {\n  F(e2, t2);\n  const r2 = null == e2 ? void 0 : e2.highWaterMark, o2 = null == e2 ? void 0 : e2.size;\n  return { highWaterMark: void 0 === r2 ? void 0 : Y(r2), size: void 0 === o2 ? void 0 : Qe(o2, `${t2} has member 'size' that`) };\n}\n__name(Ye, \"Ye\");\nfunction Qe(e2, t2) {\n  return I(e2, t2), (t3) => Y(e2(t3));\n}\n__name(Qe, \"Qe\");\nfunction Ne(e2, t2, r2) {\n  return I(e2, r2), (r3) => w(e2, t2, [r3]);\n}\n__name(Ne, \"Ne\");\nfunction He(e2, t2, r2) {\n  return I(e2, r2), () => w(e2, t2, []);\n}\n__name(He, \"He\");\nfunction xe(e2, t2, r2) {\n  return I(e2, r2), (r3) => g(e2, t2, [r3]);\n}\n__name(xe, \"xe\");\nfunction Ve(e2, t2, r2) {\n  return I(e2, r2), (r3, o2) => w(e2, t2, [r3, o2]);\n}\n__name(Ve, \"Ve\");\nObject.defineProperties(ReadableStreamBYOBReader.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), n(ReadableStreamBYOBReader.prototype.cancel, \"cancel\"), n(ReadableStreamBYOBReader.prototype.read, \"read\"), n(ReadableStreamBYOBReader.prototype.releaseLock, \"releaseLock\"), \"symbol\" == typeof e.toStringTag && Object.defineProperty(ReadableStreamBYOBReader.prototype, e.toStringTag, { value: \"ReadableStreamBYOBReader\", configurable: true });\nvar Ue = \"function\" == typeof AbortController;\nvar WritableStream = class {\n  constructor(e2 = {}, t2 = {}) {\n    void 0 === e2 ? e2 = null : D(e2, \"First parameter\");\n    const r2 = Ye(t2, \"Second parameter\"), o2 = function(e3, t3) {\n      F(e3, t3);\n      const r3 = null == e3 ? void 0 : e3.abort, o3 = null == e3 ? void 0 : e3.close, n3 = null == e3 ? void 0 : e3.start, a3 = null == e3 ? void 0 : e3.type, i2 = null == e3 ? void 0 : e3.write;\n      return { abort: void 0 === r3 ? void 0 : Ne(r3, e3, `${t3} has member 'abort' that`), close: void 0 === o3 ? void 0 : He(o3, e3, `${t3} has member 'close' that`), start: void 0 === n3 ? void 0 : xe(n3, e3, `${t3} has member 'start' that`), write: void 0 === i2 ? void 0 : Ve(i2, e3, `${t3} has member 'write' that`), type: a3 };\n    }(e2, \"First parameter\");\n    var n2;\n    (n2 = this)._state = \"writable\", n2._storedError = void 0, n2._writer = void 0, n2._writableStreamController = void 0, n2._writeRequests = new S(), n2._inFlightWriteRequest = void 0, n2._closeRequest = void 0, n2._inFlightCloseRequest = void 0, n2._pendingAbortRequest = void 0, n2._backpressure = false;\n    if (void 0 !== o2.type)\n      throw new RangeError(\"Invalid type is specified\");\n    const a2 = Me(r2);\n    !function(e3, t3, r3, o3) {\n      const n3 = Object.create(WritableStreamDefaultController.prototype);\n      let a3, i2, l2, s2;\n      a3 = void 0 !== t3.start ? () => t3.start(n3) : () => {\n      };\n      i2 = void 0 !== t3.write ? (e4) => t3.write(e4, n3) : () => c(void 0);\n      l2 = void 0 !== t3.close ? () => t3.close() : () => c(void 0);\n      s2 = void 0 !== t3.abort ? (e4) => t3.abort(e4) : () => c(void 0);\n      !function(e4, t4, r4, o4, n4, a4, i3, l3) {\n        t4._controlledWritableStream = e4, e4._writableStreamController = t4, t4._queue = void 0, t4._queueTotalSize = void 0, ce(t4), t4._abortReason = void 0, t4._abortController = function() {\n          if (Ue)\n            return new AbortController();\n        }(), t4._started = false, t4._strategySizeAlgorithm = l3, t4._strategyHWM = i3, t4._writeAlgorithm = o4, t4._closeAlgorithm = n4, t4._abortAlgorithm = a4;\n        const s3 = bt(t4);\n        nt(e4, s3);\n        const u2 = r4();\n        b(c(u2), () => (t4._started = true, dt(t4), null), (r5) => (t4._started = true, Ze(e4, r5), null));\n      }(e3, n3, a3, i2, l2, s2, r3, o3);\n    }(this, o2, $e(r2, 1), a2);\n  }\n  get locked() {\n    if (!Ge(this))\n      throw _t(\"locked\");\n    return Xe(this);\n  }\n  abort(e2) {\n    return Ge(this) ? Xe(this) ? d(new TypeError(\"Cannot abort a stream that already has a writer\")) : Je(this, e2) : d(_t(\"abort\"));\n  }\n  close() {\n    return Ge(this) ? Xe(this) ? d(new TypeError(\"Cannot close a stream that already has a writer\")) : rt(this) ? d(new TypeError(\"Cannot close an already-closing stream\")) : Ke(this) : d(_t(\"close\"));\n  }\n  getWriter() {\n    if (!Ge(this))\n      throw _t(\"getWriter\");\n    return new WritableStreamDefaultWriter(this);\n  }\n};\n__name(WritableStream, \"WritableStream\");\nfunction Ge(e2) {\n  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, \"_writableStreamController\") && e2 instanceof WritableStream);\n}\n__name(Ge, \"Ge\");\nfunction Xe(e2) {\n  return void 0 !== e2._writer;\n}\n__name(Xe, \"Xe\");\nfunction Je(e2, t2) {\n  var r2;\n  if (\"closed\" === e2._state || \"errored\" === e2._state)\n    return c(void 0);\n  e2._writableStreamController._abortReason = t2, null === (r2 = e2._writableStreamController._abortController) || void 0 === r2 || r2.abort(t2);\n  const o2 = e2._state;\n  if (\"closed\" === o2 || \"errored\" === o2)\n    return c(void 0);\n  if (void 0 !== e2._pendingAbortRequest)\n    return e2._pendingAbortRequest._promise;\n  let n2 = false;\n  \"erroring\" === o2 && (n2 = true, t2 = void 0);\n  const a2 = u((r3, o3) => {\n    e2._pendingAbortRequest = { _promise: void 0, _resolve: r3, _reject: o3, _reason: t2, _wasAlreadyErroring: n2 };\n  });\n  return e2._pendingAbortRequest._promise = a2, n2 || et(e2, t2), a2;\n}\n__name(Je, \"Je\");\nfunction Ke(e2) {\n  const t2 = e2._state;\n  if (\"closed\" === t2 || \"errored\" === t2)\n    return d(new TypeError(`The stream (in ${t2} state) is not in the writable state and cannot be closed`));\n  const r2 = u((t3, r3) => {\n    const o3 = { _resolve: t3, _reject: r3 };\n    e2._closeRequest = o3;\n  }), o2 = e2._writer;\n  var n2;\n  return void 0 !== o2 && e2._backpressure && \"writable\" === t2 && Et(o2), ue(n2 = e2._writableStreamController, lt, 0), dt(n2), r2;\n}\n__name(Ke, \"Ke\");\nfunction Ze(e2, t2) {\n  \"writable\" !== e2._state ? tt(e2) : et(e2, t2);\n}\n__name(Ze, \"Ze\");\nfunction et(e2, t2) {\n  const r2 = e2._writableStreamController;\n  e2._state = \"erroring\", e2._storedError = t2;\n  const o2 = e2._writer;\n  void 0 !== o2 && it(o2, t2), !function(e3) {\n    if (void 0 === e3._inFlightWriteRequest && void 0 === e3._inFlightCloseRequest)\n      return false;\n    return true;\n  }(e2) && r2._started && tt(e2);\n}\n__name(et, \"et\");\nfunction tt(e2) {\n  e2._state = \"errored\", e2._writableStreamController[R]();\n  const t2 = e2._storedError;\n  if (e2._writeRequests.forEach((e3) => {\n    e3._reject(t2);\n  }), e2._writeRequests = new S(), void 0 === e2._pendingAbortRequest)\n    return void ot(e2);\n  const r2 = e2._pendingAbortRequest;\n  if (e2._pendingAbortRequest = void 0, r2._wasAlreadyErroring)\n    return r2._reject(t2), void ot(e2);\n  b(e2._writableStreamController[v](r2._reason), () => (r2._resolve(), ot(e2), null), (t3) => (r2._reject(t3), ot(e2), null));\n}\n__name(tt, \"tt\");\nfunction rt(e2) {\n  return void 0 !== e2._closeRequest || void 0 !== e2._inFlightCloseRequest;\n}\n__name(rt, \"rt\");\nfunction ot(e2) {\n  void 0 !== e2._closeRequest && (e2._closeRequest._reject(e2._storedError), e2._closeRequest = void 0);\n  const t2 = e2._writer;\n  void 0 !== t2 && St(t2, e2._storedError);\n}\n__name(ot, \"ot\");\nfunction nt(e2, t2) {\n  const r2 = e2._writer;\n  void 0 !== r2 && t2 !== e2._backpressure && (t2 ? function(e3) {\n    Rt(e3);\n  }(r2) : Et(r2)), e2._backpressure = t2;\n}\n__name(nt, \"nt\");\nObject.defineProperties(WritableStream.prototype, { abort: { enumerable: true }, close: { enumerable: true }, getWriter: { enumerable: true }, locked: { enumerable: true } }), n(WritableStream.prototype.abort, \"abort\"), n(WritableStream.prototype.close, \"close\"), n(WritableStream.prototype.getWriter, \"getWriter\"), \"symbol\" == typeof e.toStringTag && Object.defineProperty(WritableStream.prototype, e.toStringTag, { value: \"WritableStream\", configurable: true });\nvar WritableStreamDefaultWriter = class {\n  constructor(e2) {\n    if ($(e2, 1, \"WritableStreamDefaultWriter\"), function(e3, t3) {\n      if (!Ge(e3))\n        throw new TypeError(`${t3} is not a WritableStream.`);\n    }(e2, \"First parameter\"), Xe(e2))\n      throw new TypeError(\"This stream has already been locked for exclusive writing by another writer\");\n    this._ownerWritableStream = e2, e2._writer = this;\n    const t2 = e2._state;\n    if (\"writable\" === t2)\n      !rt(e2) && e2._backpressure ? Rt(this) : qt(this), gt(this);\n    else if (\"erroring\" === t2)\n      Tt(this, e2._storedError), gt(this);\n    else if (\"closed\" === t2)\n      qt(this), gt(r2 = this), vt(r2);\n    else {\n      const t3 = e2._storedError;\n      Tt(this, t3), wt(this, t3);\n    }\n    var r2;\n  }\n  get closed() {\n    return at(this) ? this._closedPromise : d(mt(\"closed\"));\n  }\n  get desiredSize() {\n    if (!at(this))\n      throw mt(\"desiredSize\");\n    if (void 0 === this._ownerWritableStream)\n      throw yt(\"desiredSize\");\n    return function(e2) {\n      const t2 = e2._ownerWritableStream, r2 = t2._state;\n      if (\"errored\" === r2 || \"erroring\" === r2)\n        return null;\n      if (\"closed\" === r2)\n        return 0;\n      return ct(t2._writableStreamController);\n    }(this);\n  }\n  get ready() {\n    return at(this) ? this._readyPromise : d(mt(\"ready\"));\n  }\n  abort(e2) {\n    return at(this) ? void 0 === this._ownerWritableStream ? d(yt(\"abort\")) : function(e3, t2) {\n      return Je(e3._ownerWritableStream, t2);\n    }(this, e2) : d(mt(\"abort\"));\n  }\n  close() {\n    if (!at(this))\n      return d(mt(\"close\"));\n    const e2 = this._ownerWritableStream;\n    return void 0 === e2 ? d(yt(\"close\")) : rt(e2) ? d(new TypeError(\"Cannot close an already-closing stream\")) : Ke(this._ownerWritableStream);\n  }\n  releaseLock() {\n    if (!at(this))\n      throw mt(\"releaseLock\");\n    void 0 !== this._ownerWritableStream && function(e2) {\n      const t2 = e2._ownerWritableStream, r2 = new TypeError(\"Writer was released and can no longer be used to monitor the stream's closedness\");\n      it(e2, r2), function(e3, t3) {\n        \"pending\" === e3._closedPromiseState ? St(e3, t3) : function(e4, t4) {\n          wt(e4, t4);\n        }(e3, t3);\n      }(e2, r2), t2._writer = void 0, e2._ownerWritableStream = void 0;\n    }(this);\n  }\n  write(e2) {\n    return at(this) ? void 0 === this._ownerWritableStream ? d(yt(\"write to\")) : function(e3, t2) {\n      const r2 = e3._ownerWritableStream, o2 = r2._writableStreamController, n2 = function(e4, t3) {\n        try {\n          return e4._strategySizeAlgorithm(t3);\n        } catch (t4) {\n          return ft(e4, t4), 1;\n        }\n      }(o2, t2);\n      if (r2 !== e3._ownerWritableStream)\n        return d(yt(\"write to\"));\n      const a2 = r2._state;\n      if (\"errored\" === a2)\n        return d(r2._storedError);\n      if (rt(r2) || \"closed\" === a2)\n        return d(new TypeError(\"The stream is closing or closed and cannot be written to\"));\n      if (\"erroring\" === a2)\n        return d(r2._storedError);\n      const i2 = function(e4) {\n        return u((t3, r3) => {\n          const o3 = { _resolve: t3, _reject: r3 };\n          e4._writeRequests.push(o3);\n        });\n      }(r2);\n      return function(e4, t3, r3) {\n        try {\n          ue(e4, t3, r3);\n        } catch (t4) {\n          return void ft(e4, t4);\n        }\n        const o3 = e4._controlledWritableStream;\n        if (!rt(o3) && \"writable\" === o3._state) {\n          nt(o3, bt(e4));\n        }\n        dt(e4);\n      }(o2, t2, n2), i2;\n    }(this, e2) : d(mt(\"write\"));\n  }\n};\n__name(WritableStreamDefaultWriter, \"WritableStreamDefaultWriter\");\nfunction at(e2) {\n  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, \"_ownerWritableStream\") && e2 instanceof WritableStreamDefaultWriter);\n}\n__name(at, \"at\");\nfunction it(e2, t2) {\n  \"pending\" === e2._readyPromiseState ? Ct(e2, t2) : function(e3, t3) {\n    Tt(e3, t3);\n  }(e2, t2);\n}\n__name(it, \"it\");\nObject.defineProperties(WritableStreamDefaultWriter.prototype, { abort: { enumerable: true }, close: { enumerable: true }, releaseLock: { enumerable: true }, write: { enumerable: true }, closed: { enumerable: true }, desiredSize: { enumerable: true }, ready: { enumerable: true } }), n(WritableStreamDefaultWriter.prototype.abort, \"abort\"), n(WritableStreamDefaultWriter.prototype.close, \"close\"), n(WritableStreamDefaultWriter.prototype.releaseLock, \"releaseLock\"), n(WritableStreamDefaultWriter.prototype.write, \"write\"), \"symbol\" == typeof e.toStringTag && Object.defineProperty(WritableStreamDefaultWriter.prototype, e.toStringTag, { value: \"WritableStreamDefaultWriter\", configurable: true });\nvar lt = {};\nvar WritableStreamDefaultController = class {\n  constructor() {\n    throw new TypeError(\"Illegal constructor\");\n  }\n  get abortReason() {\n    if (!st(this))\n      throw pt(\"abortReason\");\n    return this._abortReason;\n  }\n  get signal() {\n    if (!st(this))\n      throw pt(\"signal\");\n    if (void 0 === this._abortController)\n      throw new TypeError(\"WritableStreamDefaultController.prototype.signal is not supported\");\n    return this._abortController.signal;\n  }\n  error(e2) {\n    if (!st(this))\n      throw pt(\"error\");\n    \"writable\" === this._controlledWritableStream._state && ht(this, e2);\n  }\n  [v](e2) {\n    const t2 = this._abortAlgorithm(e2);\n    return ut(this), t2;\n  }\n  [R]() {\n    ce(this);\n  }\n};\n__name(WritableStreamDefaultController, \"WritableStreamDefaultController\");\nfunction st(e2) {\n  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, \"_controlledWritableStream\") && e2 instanceof WritableStreamDefaultController);\n}\n__name(st, \"st\");\nfunction ut(e2) {\n  e2._writeAlgorithm = void 0, e2._closeAlgorithm = void 0, e2._abortAlgorithm = void 0, e2._strategySizeAlgorithm = void 0;\n}\n__name(ut, \"ut\");\nfunction ct(e2) {\n  return e2._strategyHWM - e2._queueTotalSize;\n}\n__name(ct, \"ct\");\nfunction dt(e2) {\n  const t2 = e2._controlledWritableStream;\n  if (!e2._started)\n    return;\n  if (void 0 !== t2._inFlightWriteRequest)\n    return;\n  if (\"erroring\" === t2._state)\n    return void tt(t2);\n  if (0 === e2._queue.length)\n    return;\n  const r2 = e2._queue.peek().value;\n  r2 === lt ? function(e3) {\n    const t3 = e3._controlledWritableStream;\n    (function(e4) {\n      e4._inFlightCloseRequest = e4._closeRequest, e4._closeRequest = void 0;\n    })(t3), se(e3);\n    const r3 = e3._closeAlgorithm();\n    ut(e3), b(r3, () => (function(e4) {\n      e4._inFlightCloseRequest._resolve(void 0), e4._inFlightCloseRequest = void 0, \"erroring\" === e4._state && (e4._storedError = void 0, void 0 !== e4._pendingAbortRequest && (e4._pendingAbortRequest._resolve(), e4._pendingAbortRequest = void 0)), e4._state = \"closed\";\n      const t4 = e4._writer;\n      void 0 !== t4 && vt(t4);\n    }(t3), null), (e4) => (function(e5, t4) {\n      e5._inFlightCloseRequest._reject(t4), e5._inFlightCloseRequest = void 0, void 0 !== e5._pendingAbortRequest && (e5._pendingAbortRequest._reject(t4), e5._pendingAbortRequest = void 0), Ze(e5, t4);\n    }(t3, e4), null));\n  }(e2) : function(e3, t3) {\n    const r3 = e3._controlledWritableStream;\n    !function(e4) {\n      e4._inFlightWriteRequest = e4._writeRequests.shift();\n    }(r3);\n    b(e3._writeAlgorithm(t3), () => {\n      !function(e4) {\n        e4._inFlightWriteRequest._resolve(void 0), e4._inFlightWriteRequest = void 0;\n      }(r3);\n      const t4 = r3._state;\n      if (se(e3), !rt(r3) && \"writable\" === t4) {\n        const t5 = bt(e3);\n        nt(r3, t5);\n      }\n      return dt(e3), null;\n    }, (t4) => (\"writable\" === r3._state && ut(e3), function(e4, t5) {\n      e4._inFlightWriteRequest._reject(t5), e4._inFlightWriteRequest = void 0, Ze(e4, t5);\n    }(r3, t4), null));\n  }(e2, r2);\n}\n__name(dt, \"dt\");\nfunction ft(e2, t2) {\n  \"writable\" === e2._controlledWritableStream._state && ht(e2, t2);\n}\n__name(ft, \"ft\");\nfunction bt(e2) {\n  return ct(e2) <= 0;\n}\n__name(bt, \"bt\");\nfunction ht(e2, t2) {\n  const r2 = e2._controlledWritableStream;\n  ut(e2), et(r2, t2);\n}\n__name(ht, \"ht\");\nfunction _t(e2) {\n  return new TypeError(`WritableStream.prototype.${e2} can only be used on a WritableStream`);\n}\n__name(_t, \"_t\");\nfunction pt(e2) {\n  return new TypeError(`WritableStreamDefaultController.prototype.${e2} can only be used on a WritableStreamDefaultController`);\n}\n__name(pt, \"pt\");\nfunction mt(e2) {\n  return new TypeError(`WritableStreamDefaultWriter.prototype.${e2} can only be used on a WritableStreamDefaultWriter`);\n}\n__name(mt, \"mt\");\nfunction yt(e2) {\n  return new TypeError(\"Cannot \" + e2 + \" a stream using a released writer\");\n}\n__name(yt, \"yt\");\nfunction gt(e2) {\n  e2._closedPromise = u((t2, r2) => {\n    e2._closedPromise_resolve = t2, e2._closedPromise_reject = r2, e2._closedPromiseState = \"pending\";\n  });\n}\n__name(gt, \"gt\");\nfunction wt(e2, t2) {\n  gt(e2), St(e2, t2);\n}\n__name(wt, \"wt\");\nfunction St(e2, t2) {\n  void 0 !== e2._closedPromise_reject && (m(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0, e2._closedPromiseState = \"rejected\");\n}\n__name(St, \"St\");\nfunction vt(e2) {\n  void 0 !== e2._closedPromise_resolve && (e2._closedPromise_resolve(void 0), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0, e2._closedPromiseState = \"resolved\");\n}\n__name(vt, \"vt\");\nfunction Rt(e2) {\n  e2._readyPromise = u((t2, r2) => {\n    e2._readyPromise_resolve = t2, e2._readyPromise_reject = r2;\n  }), e2._readyPromiseState = \"pending\";\n}\n__name(Rt, \"Rt\");\nfunction Tt(e2, t2) {\n  Rt(e2), Ct(e2, t2);\n}\n__name(Tt, \"Tt\");\nfunction qt(e2) {\n  Rt(e2), Et(e2);\n}\n__name(qt, \"qt\");\nfunction Ct(e2, t2) {\n  void 0 !== e2._readyPromise_reject && (m(e2._readyPromise), e2._readyPromise_reject(t2), e2._readyPromise_resolve = void 0, e2._readyPromise_reject = void 0, e2._readyPromiseState = \"rejected\");\n}\n__name(Ct, \"Ct\");\nfunction Et(e2) {\n  void 0 !== e2._readyPromise_resolve && (e2._readyPromise_resolve(void 0), e2._readyPromise_resolve = void 0, e2._readyPromise_reject = void 0, e2._readyPromiseState = \"fulfilled\");\n}\n__name(Et, \"Et\");\nObject.defineProperties(WritableStreamDefaultController.prototype, { abortReason: { enumerable: true }, signal: { enumerable: true }, error: { enumerable: true } }), \"symbol\" == typeof e.toStringTag && Object.defineProperty(WritableStreamDefaultController.prototype, e.toStringTag, { value: \"WritableStreamDefaultController\", configurable: true });\nvar Pt = \"undefined\" != typeof DOMException ? DOMException : void 0;\nvar Wt = function(e2) {\n  if (\"function\" != typeof e2 && \"object\" != typeof e2)\n    return false;\n  try {\n    return new e2(), true;\n  } catch (e3) {\n    return false;\n  }\n}(Pt) ? Pt : function() {\n  const e2 = /* @__PURE__ */ __name(function(e3, t2) {\n    this.message = e3 || \"\", this.name = t2 || \"Error\", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);\n  }, \"e\");\n  return e2.prototype = Object.create(Error.prototype), Object.defineProperty(e2.prototype, \"constructor\", { value: e2, writable: true, configurable: true }), e2;\n}();\nfunction kt(e2, t2, r2, o2, n2, a2) {\n  const i2 = e2.getReader(), l2 = t2.getWriter();\n  Vt(e2) && (e2._disturbed = true);\n  let s2, _2, g2, w2 = false, S2 = false, v2 = \"readable\", R2 = \"writable\", T2 = false, q2 = false;\n  const C2 = u((e3) => {\n    g2 = e3;\n  });\n  let E2 = Promise.resolve(void 0);\n  return u((P2, W2) => {\n    let k2;\n    function O2() {\n      if (w2)\n        return;\n      const e3 = u((e4, t3) => {\n        !(/* @__PURE__ */ __name(function r3(o3) {\n          o3 ? e4() : f(function() {\n            if (w2)\n              return c(true);\n            return f(l2.ready, () => f(i2.read(), (e5) => !!e5.done || (E2 = l2.write(e5.value), m(E2), false)));\n          }(), r3, t3);\n        }, \"r\"))(false);\n      });\n      m(e3);\n    }\n    __name(O2, \"O\");\n    function B2() {\n      return v2 = \"closed\", r2 ? L2() : z2(() => (Ge(t2) && (T2 = rt(t2), R2 = t2._state), T2 || \"closed\" === R2 ? c(void 0) : \"erroring\" === R2 || \"errored\" === R2 ? d(_2) : (T2 = true, l2.close())), false, void 0), null;\n    }\n    __name(B2, \"B\");\n    function A2(e3) {\n      return w2 || (v2 = \"errored\", s2 = e3, o2 ? L2(true, e3) : z2(() => l2.abort(e3), true, e3)), null;\n    }\n    __name(A2, \"A\");\n    function j2(e3) {\n      return S2 || (R2 = \"errored\", _2 = e3, n2 ? L2(true, e3) : z2(() => i2.cancel(e3), true, e3)), null;\n    }\n    __name(j2, \"j\");\n    if (void 0 !== a2 && (k2 = /* @__PURE__ */ __name(() => {\n      const e3 = void 0 !== a2.reason ? a2.reason : new Wt(\"Aborted\", \"AbortError\"), t3 = [];\n      o2 || t3.push(() => \"writable\" === R2 ? l2.abort(e3) : c(void 0)), n2 || t3.push(() => \"readable\" === v2 ? i2.cancel(e3) : c(void 0)), z2(() => Promise.all(t3.map((e4) => e4())), true, e3);\n    }, \"k\"), a2.aborted ? k2() : a2.addEventListener(\"abort\", k2)), Vt(e2) && (v2 = e2._state, s2 = e2._storedError), Ge(t2) && (R2 = t2._state, _2 = t2._storedError, T2 = rt(t2)), Vt(e2) && Ge(t2) && (q2 = true, g2()), \"errored\" === v2)\n      A2(s2);\n    else if (\"erroring\" === R2 || \"errored\" === R2)\n      j2(_2);\n    else if (\"closed\" === v2)\n      B2();\n    else if (T2 || \"closed\" === R2) {\n      const e3 = new TypeError(\"the destination writable stream closed before all data could be piped to it\");\n      n2 ? L2(true, e3) : z2(() => i2.cancel(e3), true, e3);\n    }\n    function z2(e3, t3, r3) {\n      function o3() {\n        return \"writable\" !== R2 || T2 ? n3() : h(function() {\n          let e4;\n          return c((/* @__PURE__ */ __name(function t4() {\n            if (e4 !== E2)\n              return e4 = E2, p(E2, t4, t4);\n          }, \"t\"))());\n        }(), n3), null;\n      }\n      __name(o3, \"o\");\n      function n3() {\n        return e3 ? b(e3(), () => F2(t3, r3), (e4) => F2(true, e4)) : F2(t3, r3), null;\n      }\n      __name(n3, \"n\");\n      w2 || (w2 = true, q2 ? o3() : h(C2, o3));\n    }\n    __name(z2, \"z\");\n    function L2(e3, t3) {\n      z2(void 0, e3, t3);\n    }\n    __name(L2, \"L\");\n    function F2(e3, t3) {\n      return S2 = true, l2.releaseLock(), i2.releaseLock(), void 0 !== a2 && a2.removeEventListener(\"abort\", k2), e3 ? W2(t3) : P2(void 0), null;\n    }\n    __name(F2, \"F\");\n    w2 || (b(i2.closed, B2, A2), b(l2.closed, function() {\n      return S2 || (R2 = \"closed\"), null;\n    }, j2)), q2 ? O2() : y(() => {\n      q2 = true, g2(), O2();\n    });\n  });\n}\n__name(kt, \"kt\");\nfunction Ot(e2, t2) {\n  return function(e3) {\n    try {\n      return e3.getReader({ mode: \"byob\" }).releaseLock(), true;\n    } catch (e4) {\n      return false;\n    }\n  }(e2) ? function(e3) {\n    let t3, r2, o2, n2, a2, i2 = e3.getReader(), l2 = false, s2 = false, d2 = false, f2 = false, h2 = false, p2 = false;\n    const m2 = u((e4) => {\n      a2 = e4;\n    });\n    function y2(e4) {\n      _(e4.closed, (t4) => (e4 !== i2 || (o2.error(t4), n2.error(t4), h2 && p2 || a2(void 0)), null));\n    }\n    __name(y2, \"y\");\n    function g2() {\n      l2 && (i2.releaseLock(), i2 = e3.getReader(), y2(i2), l2 = false), b(i2.read(), (e4) => {\n        var t4, r3;\n        if (d2 = false, f2 = false, e4.done)\n          return h2 || o2.close(), p2 || n2.close(), null === (t4 = o2.byobRequest) || void 0 === t4 || t4.respond(0), null === (r3 = n2.byobRequest) || void 0 === r3 || r3.respond(0), h2 && p2 || a2(void 0), null;\n        const l3 = e4.value, u2 = l3;\n        let c2 = l3;\n        if (!h2 && !p2)\n          try {\n            c2 = le(l3);\n          } catch (e5) {\n            return o2.error(e5), n2.error(e5), a2(i2.cancel(e5)), null;\n          }\n        return h2 || o2.enqueue(u2), p2 || n2.enqueue(c2), s2 = false, d2 ? S2() : f2 && v2(), null;\n      }, () => (s2 = false, null));\n    }\n    __name(g2, \"g\");\n    function w2(t4, r3) {\n      l2 || (i2.releaseLock(), i2 = e3.getReader({ mode: \"byob\" }), y2(i2), l2 = true);\n      const u2 = r3 ? n2 : o2, c2 = r3 ? o2 : n2;\n      b(i2.read(t4), (e4) => {\n        var t5;\n        d2 = false, f2 = false;\n        const o3 = r3 ? p2 : h2, n3 = r3 ? h2 : p2;\n        if (e4.done) {\n          o3 || u2.close(), n3 || c2.close();\n          const r4 = e4.value;\n          return void 0 !== r4 && (o3 || u2.byobRequest.respondWithNewView(r4), n3 || null === (t5 = c2.byobRequest) || void 0 === t5 || t5.respond(0)), o3 && n3 || a2(void 0), null;\n        }\n        const l3 = e4.value;\n        if (n3)\n          o3 || u2.byobRequest.respondWithNewView(l3);\n        else {\n          let e5;\n          try {\n            e5 = le(l3);\n          } catch (e6) {\n            return u2.error(e6), c2.error(e6), a2(i2.cancel(e6)), null;\n          }\n          o3 || u2.byobRequest.respondWithNewView(l3), c2.enqueue(e5);\n        }\n        return s2 = false, d2 ? S2() : f2 && v2(), null;\n      }, () => (s2 = false, null));\n    }\n    __name(w2, \"w\");\n    function S2() {\n      if (s2)\n        return d2 = true, c(void 0);\n      s2 = true;\n      const e4 = o2.byobRequest;\n      return null === e4 ? g2() : w2(e4.view, false), c(void 0);\n    }\n    __name(S2, \"S\");\n    function v2() {\n      if (s2)\n        return f2 = true, c(void 0);\n      s2 = true;\n      const e4 = n2.byobRequest;\n      return null === e4 ? g2() : w2(e4.view, true), c(void 0);\n    }\n    __name(v2, \"v\");\n    function R2(e4) {\n      if (h2 = true, t3 = e4, p2) {\n        const e5 = [t3, r2], o3 = i2.cancel(e5);\n        a2(o3);\n      }\n      return m2;\n    }\n    __name(R2, \"R\");\n    function T2(e4) {\n      if (p2 = true, r2 = e4, h2) {\n        const e5 = [t3, r2], o3 = i2.cancel(e5);\n        a2(o3);\n      }\n      return m2;\n    }\n    __name(T2, \"T\");\n    const q2 = new ReadableStream({ type: \"bytes\", start(e4) {\n      o2 = e4;\n    }, pull: S2, cancel: R2 }), C2 = new ReadableStream({ type: \"bytes\", start(e4) {\n      n2 = e4;\n    }, pull: v2, cancel: T2 });\n    return y2(i2), [q2, C2];\n  }(e2) : function(e3, t3) {\n    const r2 = e3.getReader();\n    let o2, n2, a2, i2, l2, s2 = false, d2 = false, f2 = false, h2 = false;\n    const p2 = u((e4) => {\n      l2 = e4;\n    });\n    function m2() {\n      return s2 ? (d2 = true, c(void 0)) : (s2 = true, b(r2.read(), (e4) => {\n        if (d2 = false, e4.done)\n          return f2 || a2.close(), h2 || i2.close(), f2 && h2 || l2(void 0), null;\n        const t4 = e4.value, r3 = t4, o3 = t4;\n        return f2 || a2.enqueue(r3), h2 || i2.enqueue(o3), s2 = false, d2 && m2(), null;\n      }, () => (s2 = false, null)), c(void 0));\n    }\n    __name(m2, \"m\");\n    function y2(e4) {\n      if (f2 = true, o2 = e4, h2) {\n        const e5 = [o2, n2], t4 = r2.cancel(e5);\n        l2(t4);\n      }\n      return p2;\n    }\n    __name(y2, \"y\");\n    function g2(e4) {\n      if (h2 = true, n2 = e4, f2) {\n        const e5 = [o2, n2], t4 = r2.cancel(e5);\n        l2(t4);\n      }\n      return p2;\n    }\n    __name(g2, \"g\");\n    const w2 = new ReadableStream({ start(e4) {\n      a2 = e4;\n    }, pull: m2, cancel: y2 }), S2 = new ReadableStream({ start(e4) {\n      i2 = e4;\n    }, pull: m2, cancel: g2 });\n    return _(r2.closed, (e4) => (a2.error(e4), i2.error(e4), f2 && h2 || l2(void 0), null)), [w2, S2];\n  }(e2);\n}\n__name(Ot, \"Ot\");\nvar ReadableStreamDefaultController = class {\n  constructor() {\n    throw new TypeError(\"Illegal constructor\");\n  }\n  get desiredSize() {\n    if (!Bt(this))\n      throw Dt(\"desiredSize\");\n    return Lt(this);\n  }\n  close() {\n    if (!Bt(this))\n      throw Dt(\"close\");\n    if (!Ft(this))\n      throw new TypeError(\"The stream is not in a state that permits close\");\n    !function(e2) {\n      if (!Ft(e2))\n        return;\n      const t2 = e2._controlledReadableStream;\n      e2._closeRequested = true, 0 === e2._queue.length && (jt(e2), Xt(t2));\n    }(this);\n  }\n  enqueue(e2) {\n    if (!Bt(this))\n      throw Dt(\"enqueue\");\n    if (!Ft(this))\n      throw new TypeError(\"The stream is not in a state that permits enqueue\");\n    return function(e3, t2) {\n      if (!Ft(e3))\n        return;\n      const r2 = e3._controlledReadableStream;\n      if (Ut(r2) && X(r2) > 0)\n        G(r2, t2, false);\n      else {\n        let r3;\n        try {\n          r3 = e3._strategySizeAlgorithm(t2);\n        } catch (t3) {\n          throw zt(e3, t3), t3;\n        }\n        try {\n          ue(e3, t2, r3);\n        } catch (t3) {\n          throw zt(e3, t3), t3;\n        }\n      }\n      At(e3);\n    }(this, e2);\n  }\n  error(e2) {\n    if (!Bt(this))\n      throw Dt(\"error\");\n    zt(this, e2);\n  }\n  [T](e2) {\n    ce(this);\n    const t2 = this._cancelAlgorithm(e2);\n    return jt(this), t2;\n  }\n  [q](e2) {\n    const t2 = this._controlledReadableStream;\n    if (this._queue.length > 0) {\n      const r2 = se(this);\n      this._closeRequested && 0 === this._queue.length ? (jt(this), Xt(t2)) : At(this), e2._chunkSteps(r2);\n    } else\n      U(t2, e2), At(this);\n  }\n  [C]() {\n  }\n};\n__name(ReadableStreamDefaultController, \"ReadableStreamDefaultController\");\nfunction Bt(e2) {\n  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, \"_controlledReadableStream\") && e2 instanceof ReadableStreamDefaultController);\n}\n__name(Bt, \"Bt\");\nfunction At(e2) {\n  const t2 = function(e3) {\n    const t3 = e3._controlledReadableStream;\n    if (!Ft(e3))\n      return false;\n    if (!e3._started)\n      return false;\n    if (Ut(t3) && X(t3) > 0)\n      return true;\n    if (Lt(e3) > 0)\n      return true;\n    return false;\n  }(e2);\n  if (!t2)\n    return;\n  if (e2._pulling)\n    return void (e2._pullAgain = true);\n  e2._pulling = true;\n  b(e2._pullAlgorithm(), () => (e2._pulling = false, e2._pullAgain && (e2._pullAgain = false, At(e2)), null), (t3) => (zt(e2, t3), null));\n}\n__name(At, \"At\");\nfunction jt(e2) {\n  e2._pullAlgorithm = void 0, e2._cancelAlgorithm = void 0, e2._strategySizeAlgorithm = void 0;\n}\n__name(jt, \"jt\");\nfunction zt(e2, t2) {\n  const r2 = e2._controlledReadableStream;\n  \"readable\" === r2._state && (ce(e2), jt(e2), Jt(r2, t2));\n}\n__name(zt, \"zt\");\nfunction Lt(e2) {\n  const t2 = e2._controlledReadableStream._state;\n  return \"errored\" === t2 ? null : \"closed\" === t2 ? 0 : e2._strategyHWM - e2._queueTotalSize;\n}\n__name(Lt, \"Lt\");\nfunction Ft(e2) {\n  return !e2._closeRequested && \"readable\" === e2._controlledReadableStream._state;\n}\n__name(Ft, \"Ft\");\nfunction It(e2, t2, r2, o2) {\n  const n2 = Object.create(ReadableStreamDefaultController.prototype);\n  let a2, i2, l2;\n  a2 = void 0 !== t2.start ? () => t2.start(n2) : () => {\n  }, i2 = void 0 !== t2.pull ? () => t2.pull(n2) : () => c(void 0), l2 = void 0 !== t2.cancel ? (e3) => t2.cancel(e3) : () => c(void 0), function(e3, t3, r3, o3, n3, a3, i3) {\n    t3._controlledReadableStream = e3, t3._queue = void 0, t3._queueTotalSize = void 0, ce(t3), t3._started = false, t3._closeRequested = false, t3._pullAgain = false, t3._pulling = false, t3._strategySizeAlgorithm = i3, t3._strategyHWM = a3, t3._pullAlgorithm = o3, t3._cancelAlgorithm = n3, e3._readableStreamController = t3, b(c(r3()), () => (t3._started = true, At(t3), null), (e4) => (zt(t3, e4), null));\n  }(e2, n2, a2, i2, l2, r2, o2);\n}\n__name(It, \"It\");\nfunction Dt(e2) {\n  return new TypeError(`ReadableStreamDefaultController.prototype.${e2} can only be used on a ReadableStreamDefaultController`);\n}\n__name(Dt, \"Dt\");\nfunction $t(e2, t2, r2) {\n  return I(e2, r2), (r3) => w(e2, t2, [r3]);\n}\n__name($t, \"$t\");\nfunction Mt(e2, t2, r2) {\n  return I(e2, r2), (r3) => w(e2, t2, [r3]);\n}\n__name(Mt, \"Mt\");\nfunction Yt(e2, t2, r2) {\n  return I(e2, r2), (r3) => g(e2, t2, [r3]);\n}\n__name(Yt, \"Yt\");\nfunction Qt(e2, t2) {\n  if (\"bytes\" !== (e2 = `${e2}`))\n    throw new TypeError(`${t2} '${e2}' is not a valid enumeration value for ReadableStreamType`);\n  return e2;\n}\n__name(Qt, \"Qt\");\nfunction Nt(e2, t2) {\n  if (\"byob\" !== (e2 = `${e2}`))\n    throw new TypeError(`${t2} '${e2}' is not a valid enumeration value for ReadableStreamReaderMode`);\n  return e2;\n}\n__name(Nt, \"Nt\");\nfunction Ht(e2, t2) {\n  F(e2, t2);\n  const r2 = null == e2 ? void 0 : e2.preventAbort, o2 = null == e2 ? void 0 : e2.preventCancel, n2 = null == e2 ? void 0 : e2.preventClose, a2 = null == e2 ? void 0 : e2.signal;\n  return void 0 !== a2 && function(e3, t3) {\n    if (!function(e4) {\n      if (\"object\" != typeof e4 || null === e4)\n        return false;\n      try {\n        return \"boolean\" == typeof e4.aborted;\n      } catch (e5) {\n        return false;\n      }\n    }(e3))\n      throw new TypeError(`${t3} is not an AbortSignal.`);\n  }(a2, `${t2} has member 'signal' that`), { preventAbort: Boolean(r2), preventCancel: Boolean(o2), preventClose: Boolean(n2), signal: a2 };\n}\n__name(Ht, \"Ht\");\nfunction xt(e2, t2) {\n  F(e2, t2);\n  const r2 = null == e2 ? void 0 : e2.readable;\n  M(r2, \"readable\", \"ReadableWritablePair\"), function(e3, t3) {\n    if (!H(e3))\n      throw new TypeError(`${t3} is not a ReadableStream.`);\n  }(r2, `${t2} has member 'readable' that`);\n  const o2 = null == e2 ? void 0 : e2.writable;\n  return M(o2, \"writable\", \"ReadableWritablePair\"), function(e3, t3) {\n    if (!x(e3))\n      throw new TypeError(`${t3} is not a WritableStream.`);\n  }(o2, `${t2} has member 'writable' that`), { readable: r2, writable: o2 };\n}\n__name(xt, \"xt\");\nObject.defineProperties(ReadableStreamDefaultController.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, desiredSize: { enumerable: true } }), n(ReadableStreamDefaultController.prototype.close, \"close\"), n(ReadableStreamDefaultController.prototype.enqueue, \"enqueue\"), n(ReadableStreamDefaultController.prototype.error, \"error\"), \"symbol\" == typeof e.toStringTag && Object.defineProperty(ReadableStreamDefaultController.prototype, e.toStringTag, { value: \"ReadableStreamDefaultController\", configurable: true });\nvar ReadableStream = class {\n  constructor(e2 = {}, t2 = {}) {\n    void 0 === e2 ? e2 = null : D(e2, \"First parameter\");\n    const r2 = Ye(t2, \"Second parameter\"), o2 = function(e3, t3) {\n      F(e3, t3);\n      const r3 = e3, o3 = null == r3 ? void 0 : r3.autoAllocateChunkSize, n3 = null == r3 ? void 0 : r3.cancel, a2 = null == r3 ? void 0 : r3.pull, i2 = null == r3 ? void 0 : r3.start, l2 = null == r3 ? void 0 : r3.type;\n      return { autoAllocateChunkSize: void 0 === o3 ? void 0 : N(o3, `${t3} has member 'autoAllocateChunkSize' that`), cancel: void 0 === n3 ? void 0 : $t(n3, r3, `${t3} has member 'cancel' that`), pull: void 0 === a2 ? void 0 : Mt(a2, r3, `${t3} has member 'pull' that`), start: void 0 === i2 ? void 0 : Yt(i2, r3, `${t3} has member 'start' that`), type: void 0 === l2 ? void 0 : Qt(l2, `${t3} has member 'type' that`) };\n    }(e2, \"First parameter\");\n    var n2;\n    if ((n2 = this)._state = \"readable\", n2._reader = void 0, n2._storedError = void 0, n2._disturbed = false, \"bytes\" === o2.type) {\n      if (void 0 !== r2.size)\n        throw new RangeError(\"The strategy for a byte stream cannot have a size function\");\n      Oe(this, o2, $e(r2, 0));\n    } else {\n      const e3 = Me(r2);\n      It(this, o2, $e(r2, 1), e3);\n    }\n  }\n  get locked() {\n    if (!Vt(this))\n      throw Kt(\"locked\");\n    return Ut(this);\n  }\n  cancel(e2) {\n    return Vt(this) ? Ut(this) ? d(new TypeError(\"Cannot cancel a stream that already has a reader\")) : Gt(this, e2) : d(Kt(\"cancel\"));\n  }\n  getReader(e2) {\n    if (!Vt(this))\n      throw Kt(\"getReader\");\n    return void 0 === function(e3, t2) {\n      F(e3, t2);\n      const r2 = null == e3 ? void 0 : e3.mode;\n      return { mode: void 0 === r2 ? void 0 : Nt(r2, `${t2} has member 'mode' that`) };\n    }(e2, \"First parameter\").mode ? new ReadableStreamDefaultReader(this) : function(e3) {\n      return new ReadableStreamBYOBReader(e3);\n    }(this);\n  }\n  pipeThrough(e2, t2 = {}) {\n    if (!H(this))\n      throw Kt(\"pipeThrough\");\n    $(e2, 1, \"pipeThrough\");\n    const r2 = xt(e2, \"First parameter\"), o2 = Ht(t2, \"Second parameter\");\n    if (this.locked)\n      throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream\");\n    if (r2.writable.locked)\n      throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream\");\n    return m(kt(this, r2.writable, o2.preventClose, o2.preventAbort, o2.preventCancel, o2.signal)), r2.readable;\n  }\n  pipeTo(e2, t2 = {}) {\n    if (!H(this))\n      return d(Kt(\"pipeTo\"));\n    if (void 0 === e2)\n      return d(\"Parameter 1 is required in 'pipeTo'.\");\n    if (!x(e2))\n      return d(new TypeError(\"ReadableStream.prototype.pipeTo's first argument must be a WritableStream\"));\n    let r2;\n    try {\n      r2 = Ht(t2, \"Second parameter\");\n    } catch (e3) {\n      return d(e3);\n    }\n    return this.locked ? d(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream\")) : e2.locked ? d(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream\")) : kt(this, e2, r2.preventClose, r2.preventAbort, r2.preventCancel, r2.signal);\n  }\n  tee() {\n    if (!H(this))\n      throw Kt(\"tee\");\n    if (this.locked)\n      throw new TypeError(\"Cannot tee a stream that already has a reader\");\n    return Ot(this);\n  }\n  values(e2) {\n    if (!H(this))\n      throw Kt(\"values\");\n    return function(e3, t2) {\n      const r2 = e3.getReader(), o2 = new te(r2, t2), n2 = Object.create(re);\n      return n2._asyncIteratorImpl = o2, n2;\n    }(this, function(e3, t2) {\n      F(e3, t2);\n      const r2 = null == e3 ? void 0 : e3.preventCancel;\n      return { preventCancel: Boolean(r2) };\n    }(e2, \"First parameter\").preventCancel);\n  }\n};\n__name(ReadableStream, \"ReadableStream\");\nfunction Vt(e2) {\n  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, \"_readableStreamController\") && e2 instanceof ReadableStream);\n}\n__name(Vt, \"Vt\");\nfunction Ut(e2) {\n  return void 0 !== e2._reader;\n}\n__name(Ut, \"Ut\");\nfunction Gt(e2, r2) {\n  if (e2._disturbed = true, \"closed\" === e2._state)\n    return c(void 0);\n  if (\"errored\" === e2._state)\n    return d(e2._storedError);\n  Xt(e2);\n  const o2 = e2._reader;\n  if (void 0 !== o2 && Fe(o2)) {\n    const e3 = o2._readIntoRequests;\n    o2._readIntoRequests = new S(), e3.forEach((e4) => {\n      e4._closeSteps(void 0);\n    });\n  }\n  return p(e2._readableStreamController[T](r2), t);\n}\n__name(Gt, \"Gt\");\nfunction Xt(e2) {\n  e2._state = \"closed\";\n  const t2 = e2._reader;\n  if (void 0 !== t2 && (j(t2), K(t2))) {\n    const e3 = t2._readRequests;\n    t2._readRequests = new S(), e3.forEach((e4) => {\n      e4._closeSteps();\n    });\n  }\n}\n__name(Xt, \"Xt\");\nfunction Jt(e2, t2) {\n  e2._state = \"errored\", e2._storedError = t2;\n  const r2 = e2._reader;\n  void 0 !== r2 && (A(r2, t2), K(r2) ? Z(r2, t2) : Ie(r2, t2));\n}\n__name(Jt, \"Jt\");\nfunction Kt(e2) {\n  return new TypeError(`ReadableStream.prototype.${e2} can only be used on a ReadableStream`);\n}\n__name(Kt, \"Kt\");\nfunction Zt(e2, t2) {\n  F(e2, t2);\n  const r2 = null == e2 ? void 0 : e2.highWaterMark;\n  return M(r2, \"highWaterMark\", \"QueuingStrategyInit\"), { highWaterMark: Y(r2) };\n}\n__name(Zt, \"Zt\");\nObject.defineProperties(ReadableStream.prototype, { cancel: { enumerable: true }, getReader: { enumerable: true }, pipeThrough: { enumerable: true }, pipeTo: { enumerable: true }, tee: { enumerable: true }, values: { enumerable: true }, locked: { enumerable: true } }), n(ReadableStream.prototype.cancel, \"cancel\"), n(ReadableStream.prototype.getReader, \"getReader\"), n(ReadableStream.prototype.pipeThrough, \"pipeThrough\"), n(ReadableStream.prototype.pipeTo, \"pipeTo\"), n(ReadableStream.prototype.tee, \"tee\"), n(ReadableStream.prototype.values, \"values\"), \"symbol\" == typeof e.toStringTag && Object.defineProperty(ReadableStream.prototype, e.toStringTag, { value: \"ReadableStream\", configurable: true }), \"symbol\" == typeof e.asyncIterator && Object.defineProperty(ReadableStream.prototype, e.asyncIterator, { value: ReadableStream.prototype.values, writable: true, configurable: true });\nvar er = /* @__PURE__ */ __name((e2) => e2.byteLength, \"er\");\nn(er, \"size\");\nvar ByteLengthQueuingStrategy = class {\n  constructor(e2) {\n    $(e2, 1, \"ByteLengthQueuingStrategy\"), e2 = Zt(e2, \"First parameter\"), this._byteLengthQueuingStrategyHighWaterMark = e2.highWaterMark;\n  }\n  get highWaterMark() {\n    if (!rr(this))\n      throw tr(\"highWaterMark\");\n    return this._byteLengthQueuingStrategyHighWaterMark;\n  }\n  get size() {\n    if (!rr(this))\n      throw tr(\"size\");\n    return er;\n  }\n};\n__name(ByteLengthQueuingStrategy, \"ByteLengthQueuingStrategy\");\nfunction tr(e2) {\n  return new TypeError(`ByteLengthQueuingStrategy.prototype.${e2} can only be used on a ByteLengthQueuingStrategy`);\n}\n__name(tr, \"tr\");\nfunction rr(e2) {\n  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, \"_byteLengthQueuingStrategyHighWaterMark\") && e2 instanceof ByteLengthQueuingStrategy);\n}\n__name(rr, \"rr\");\nObject.defineProperties(ByteLengthQueuingStrategy.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), \"symbol\" == typeof e.toStringTag && Object.defineProperty(ByteLengthQueuingStrategy.prototype, e.toStringTag, { value: \"ByteLengthQueuingStrategy\", configurable: true });\nvar or = /* @__PURE__ */ __name(() => 1, \"or\");\nn(or, \"size\");\nvar CountQueuingStrategy = class {\n  constructor(e2) {\n    $(e2, 1, \"CountQueuingStrategy\"), e2 = Zt(e2, \"First parameter\"), this._countQueuingStrategyHighWaterMark = e2.highWaterMark;\n  }\n  get highWaterMark() {\n    if (!ar(this))\n      throw nr(\"highWaterMark\");\n    return this._countQueuingStrategyHighWaterMark;\n  }\n  get size() {\n    if (!ar(this))\n      throw nr(\"size\");\n    return or;\n  }\n};\n__name(CountQueuingStrategy, \"CountQueuingStrategy\");\nfunction nr(e2) {\n  return new TypeError(`CountQueuingStrategy.prototype.${e2} can only be used on a CountQueuingStrategy`);\n}\n__name(nr, \"nr\");\nfunction ar(e2) {\n  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, \"_countQueuingStrategyHighWaterMark\") && e2 instanceof CountQueuingStrategy);\n}\n__name(ar, \"ar\");\nfunction ir(e2, t2, r2) {\n  return I(e2, r2), (r3) => w(e2, t2, [r3]);\n}\n__name(ir, \"ir\");\nfunction lr(e2, t2, r2) {\n  return I(e2, r2), (r3) => g(e2, t2, [r3]);\n}\n__name(lr, \"lr\");\nfunction sr(e2, t2, r2) {\n  return I(e2, r2), (r3, o2) => w(e2, t2, [r3, o2]);\n}\n__name(sr, \"sr\");\nObject.defineProperties(CountQueuingStrategy.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), \"symbol\" == typeof e.toStringTag && Object.defineProperty(CountQueuingStrategy.prototype, e.toStringTag, { value: \"CountQueuingStrategy\", configurable: true });\nvar TransformStream = class {\n  constructor(e2 = {}, t2 = {}, r2 = {}) {\n    void 0 === e2 && (e2 = null);\n    const o2 = Ye(t2, \"Second parameter\"), n2 = Ye(r2, \"Third parameter\"), a2 = function(e3, t3) {\n      F(e3, t3);\n      const r3 = null == e3 ? void 0 : e3.flush, o3 = null == e3 ? void 0 : e3.readableType, n3 = null == e3 ? void 0 : e3.start, a3 = null == e3 ? void 0 : e3.transform, i3 = null == e3 ? void 0 : e3.writableType;\n      return { flush: void 0 === r3 ? void 0 : ir(r3, e3, `${t3} has member 'flush' that`), readableType: o3, start: void 0 === n3 ? void 0 : lr(n3, e3, `${t3} has member 'start' that`), transform: void 0 === a3 ? void 0 : sr(a3, e3, `${t3} has member 'transform' that`), writableType: i3 };\n    }(e2, \"First parameter\");\n    if (void 0 !== a2.readableType)\n      throw new RangeError(\"Invalid readableType specified\");\n    if (void 0 !== a2.writableType)\n      throw new RangeError(\"Invalid writableType specified\");\n    const i2 = $e(n2, 0), l2 = Me(n2), s2 = $e(o2, 1), f2 = Me(o2);\n    let b2;\n    !function(e3, t3, r3, o3, n3, a3) {\n      function i3() {\n        return t3;\n      }\n      __name(i3, \"i\");\n      function l3(t4) {\n        return function(e4, t5) {\n          const r4 = e4._transformStreamController;\n          if (e4._backpressure) {\n            return p(e4._backpressureChangePromise, () => {\n              if (\"erroring\" === (Ge(e4._writable) ? e4._writable._state : e4._writableState))\n                throw Ge(e4._writable) ? e4._writable._storedError : e4._writableStoredError;\n              return pr(r4, t5);\n            });\n          }\n          return pr(r4, t5);\n        }(e3, t4);\n      }\n      __name(l3, \"l\");\n      function s3(t4) {\n        return function(e4, t5) {\n          return cr(e4, t5), c(void 0);\n        }(e3, t4);\n      }\n      __name(s3, \"s\");\n      function u2() {\n        return function(e4) {\n          const t4 = e4._transformStreamController, r4 = t4._flushAlgorithm();\n          return hr(t4), p(r4, () => {\n            if (\"errored\" === e4._readableState)\n              throw e4._readableStoredError;\n            gr(e4) && wr(e4);\n          }, (t5) => {\n            throw cr(e4, t5), e4._readableStoredError;\n          });\n        }(e3);\n      }\n      __name(u2, \"u\");\n      function d2() {\n        return function(e4) {\n          return fr(e4, false), e4._backpressureChangePromise;\n        }(e3);\n      }\n      __name(d2, \"d\");\n      function f3(t4) {\n        return dr(e3, t4), c(void 0);\n      }\n      __name(f3, \"f\");\n      e3._writableState = \"writable\", e3._writableStoredError = void 0, e3._writableHasInFlightOperation = false, e3._writableStarted = false, e3._writable = function(e4, t4, r4, o4, n4, a4, i4) {\n        return new WritableStream({ start(r5) {\n          e4._writableController = r5;\n          try {\n            const t5 = r5.signal;\n            void 0 !== t5 && t5.addEventListener(\"abort\", () => {\n              \"writable\" === e4._writableState && (e4._writableState = \"erroring\", t5.reason && (e4._writableStoredError = t5.reason));\n            });\n          } catch (e5) {\n          }\n          return p(t4(), () => (e4._writableStarted = true, Cr(e4), null), (t5) => {\n            throw e4._writableStarted = true, Rr(e4, t5), t5;\n          });\n        }, write: (t5) => (function(e5) {\n          e5._writableHasInFlightOperation = true;\n        }(e4), p(r4(t5), () => (function(e5) {\n          e5._writableHasInFlightOperation = false;\n        }(e4), Cr(e4), null), (t6) => {\n          throw function(e5, t7) {\n            e5._writableHasInFlightOperation = false, Rr(e5, t7);\n          }(e4, t6), t6;\n        })), close: () => (function(e5) {\n          e5._writableHasInFlightOperation = true;\n        }(e4), p(o4(), () => (function(e5) {\n          e5._writableHasInFlightOperation = false;\n          \"erroring\" === e5._writableState && (e5._writableStoredError = void 0);\n          e5._writableState = \"closed\";\n        }(e4), null), (t5) => {\n          throw function(e5, t6) {\n            e5._writableHasInFlightOperation = false, e5._writableState, Rr(e5, t6);\n          }(e4, t5), t5;\n        })), abort: (t5) => (e4._writableState = \"errored\", e4._writableStoredError = t5, n4(t5)) }, { highWaterMark: a4, size: i4 });\n      }(e3, i3, l3, u2, s3, r3, o3), e3._readableState = \"readable\", e3._readableStoredError = void 0, e3._readableCloseRequested = false, e3._readablePulling = false, e3._readable = function(e4, t4, r4, o4, n4, a4) {\n        return new ReadableStream({ start: (r5) => (e4._readableController = r5, t4().catch((t5) => {\n          Sr(e4, t5);\n        })), pull: () => (e4._readablePulling = true, r4().catch((t5) => {\n          Sr(e4, t5);\n        })), cancel: (t5) => (e4._readableState = \"closed\", o4(t5)) }, { highWaterMark: n4, size: a4 });\n      }(e3, i3, d2, f3, n3, a3), e3._backpressure = void 0, e3._backpressureChangePromise = void 0, e3._backpressureChangePromise_resolve = void 0, fr(e3, true), e3._transformStreamController = void 0;\n    }(this, u((e3) => {\n      b2 = e3;\n    }), s2, f2, i2, l2), function(e3, t3) {\n      const r3 = Object.create(TransformStreamDefaultController.prototype);\n      let o3, n3;\n      o3 = void 0 !== t3.transform ? (e4) => t3.transform(e4, r3) : (e4) => {\n        try {\n          return _r(r3, e4), c(void 0);\n        } catch (e5) {\n          return d(e5);\n        }\n      };\n      n3 = void 0 !== t3.flush ? () => t3.flush(r3) : () => c(void 0);\n      !function(e4, t4, r4, o4) {\n        t4._controlledTransformStream = e4, e4._transformStreamController = t4, t4._transformAlgorithm = r4, t4._flushAlgorithm = o4;\n      }(e3, r3, o3, n3);\n    }(this, a2), void 0 !== a2.start ? b2(a2.start(this._transformStreamController)) : b2(void 0);\n  }\n  get readable() {\n    if (!ur(this))\n      throw yr(\"readable\");\n    return this._readable;\n  }\n  get writable() {\n    if (!ur(this))\n      throw yr(\"writable\");\n    return this._writable;\n  }\n};\n__name(TransformStream, \"TransformStream\");\nfunction ur(e2) {\n  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, \"_transformStreamController\") && e2 instanceof TransformStream);\n}\n__name(ur, \"ur\");\nfunction cr(e2, t2) {\n  Sr(e2, t2), dr(e2, t2);\n}\n__name(cr, \"cr\");\nfunction dr(e2, t2) {\n  hr(e2._transformStreamController), function(e3, t3) {\n    e3._writableController.error(t3);\n    \"writable\" === e3._writableState && Tr(e3, t3);\n  }(e2, t2), e2._backpressure && fr(e2, false);\n}\n__name(dr, \"dr\");\nfunction fr(e2, t2) {\n  void 0 !== e2._backpressureChangePromise && e2._backpressureChangePromise_resolve(), e2._backpressureChangePromise = u((t3) => {\n    e2._backpressureChangePromise_resolve = t3;\n  }), e2._backpressure = t2;\n}\n__name(fr, \"fr\");\nObject.defineProperties(TransformStream.prototype, { readable: { enumerable: true }, writable: { enumerable: true } }), \"symbol\" == typeof e.toStringTag && Object.defineProperty(TransformStream.prototype, e.toStringTag, { value: \"TransformStream\", configurable: true });\nvar TransformStreamDefaultController = class {\n  constructor() {\n    throw new TypeError(\"Illegal constructor\");\n  }\n  get desiredSize() {\n    if (!br(this))\n      throw mr(\"desiredSize\");\n    return vr(this._controlledTransformStream);\n  }\n  enqueue(e2) {\n    if (!br(this))\n      throw mr(\"enqueue\");\n    _r(this, e2);\n  }\n  error(e2) {\n    if (!br(this))\n      throw mr(\"error\");\n    var t2;\n    t2 = e2, cr(this._controlledTransformStream, t2);\n  }\n  terminate() {\n    if (!br(this))\n      throw mr(\"terminate\");\n    !function(e2) {\n      const t2 = e2._controlledTransformStream;\n      gr(t2) && wr(t2);\n      const r2 = new TypeError(\"TransformStream terminated\");\n      dr(t2, r2);\n    }(this);\n  }\n};\n__name(TransformStreamDefaultController, \"TransformStreamDefaultController\");\nfunction br(e2) {\n  return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, \"_controlledTransformStream\") && e2 instanceof TransformStreamDefaultController);\n}\n__name(br, \"br\");\nfunction hr(e2) {\n  e2._transformAlgorithm = void 0, e2._flushAlgorithm = void 0;\n}\n__name(hr, \"hr\");\nfunction _r(e2, t2) {\n  const r2 = e2._controlledTransformStream;\n  if (!gr(r2))\n    throw new TypeError(\"Readable side is not in a state that permits enqueue\");\n  try {\n    !function(e3, t3) {\n      e3._readablePulling = false;\n      try {\n        e3._readableController.enqueue(t3);\n      } catch (t4) {\n        throw Sr(e3, t4), t4;\n      }\n    }(r2, t2);\n  } catch (e3) {\n    throw dr(r2, e3), r2._readableStoredError;\n  }\n  const o2 = function(e3) {\n    return !function(e4) {\n      if (!gr(e4))\n        return false;\n      if (e4._readablePulling)\n        return true;\n      if (vr(e4) > 0)\n        return true;\n      return false;\n    }(e3);\n  }(r2);\n  o2 !== r2._backpressure && fr(r2, true);\n}\n__name(_r, \"_r\");\nfunction pr(e2, t2) {\n  return p(e2._transformAlgorithm(t2), void 0, (t3) => {\n    throw cr(e2._controlledTransformStream, t3), t3;\n  });\n}\n__name(pr, \"pr\");\nfunction mr(e2) {\n  return new TypeError(`TransformStreamDefaultController.prototype.${e2} can only be used on a TransformStreamDefaultController`);\n}\n__name(mr, \"mr\");\nfunction yr(e2) {\n  return new TypeError(`TransformStream.prototype.${e2} can only be used on a TransformStream`);\n}\n__name(yr, \"yr\");\nfunction gr(e2) {\n  return !e2._readableCloseRequested && \"readable\" === e2._readableState;\n}\n__name(gr, \"gr\");\nfunction wr(e2) {\n  e2._readableState = \"closed\", e2._readableCloseRequested = true, e2._readableController.close();\n}\n__name(wr, \"wr\");\nfunction Sr(e2, t2) {\n  \"readable\" === e2._readableState && (e2._readableState = \"errored\", e2._readableStoredError = t2), e2._readableController.error(t2);\n}\n__name(Sr, \"Sr\");\nfunction vr(e2) {\n  return e2._readableController.desiredSize;\n}\n__name(vr, \"vr\");\nfunction Rr(e2, t2) {\n  \"writable\" !== e2._writableState ? qr(e2) : Tr(e2, t2);\n}\n__name(Rr, \"Rr\");\nfunction Tr(e2, t2) {\n  e2._writableState = \"erroring\", e2._writableStoredError = t2, !function(e3) {\n    return e3._writableHasInFlightOperation;\n  }(e2) && e2._writableStarted && qr(e2);\n}\n__name(Tr, \"Tr\");\nfunction qr(e2) {\n  e2._writableState = \"errored\";\n}\n__name(qr, \"qr\");\nfunction Cr(e2) {\n  \"erroring\" === e2._writableState && qr(e2);\n}\n__name(Cr, \"Cr\");\nObject.defineProperties(TransformStreamDefaultController.prototype, { enqueue: { enumerable: true }, error: { enumerable: true }, terminate: { enumerable: true }, desiredSize: { enumerable: true } }), n(TransformStreamDefaultController.prototype.enqueue, \"enqueue\"), n(TransformStreamDefaultController.prototype.error, \"error\"), n(TransformStreamDefaultController.prototype.terminate, \"terminate\"), \"symbol\" == typeof e.toStringTag && Object.defineProperty(TransformStreamDefaultController.prototype, e.toStringTag, { value: \"TransformStreamDefaultController\", configurable: true });\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  ReadableStream,\n  ReadableStreamBYOBReader,\n  ReadableStreamDefaultReader,\n  TransformStream,\n  WritableStream,\n  WritableStreamDefaultWriter\n});\n"