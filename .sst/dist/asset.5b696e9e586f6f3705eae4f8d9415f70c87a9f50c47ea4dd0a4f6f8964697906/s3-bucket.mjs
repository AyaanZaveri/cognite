import { createRequire as topLevelCreateRequire } from 'module';const require = topLevelCreateRequire(import.meta.url);
import{createRequire as I}from"module";function r(t,...e){console.log("[provider-framework]",t,...e.map(o=>typeof o=="object"?JSON.stringify(o,void 0,2):o))}import R from"https";import g from"url";var d="AWSCDK::CustomResourceProviderFramework::CREATE_FAILED",y="AWSCDK::CustomResourceProviderFramework::MISSING_PHYSICAL_ID";async function c(t,e,o={}){let n={Status:t,Reason:o.reason||t,StackId:e.StackId,RequestId:e.RequestId,PhysicalResourceId:e.PhysicalResourceId||y,LogicalResourceId:e.LogicalResourceId,NoEcho:o.noEcho,Data:e.Data};r("submit response to cloudformation",n);let s=JSON.stringify(n),a=g.parse(e.ResponseURL);await E({hostname:a.hostname,path:a.path,method:"PUT",headers:{"content-type":"","content-length":s.length}},s)}function p(t){return async e=>{if(e.RequestType==="Delete"&&e.PhysicalResourceId===d){r("ignoring DELETE event caused by a failed CREATE event"),await c("SUCCESS",e);return}try{await t(e)}catch(o){if(r(o),o instanceof u)throw r("retry requested by handler"),o;e.PhysicalResourceId||(e.RequestType==="Create"?(r("CREATE failed, responding with a marker physical resource id so that the subsequent DELETE will be ignored"),e.PhysicalResourceId=d):r(`ERROR: Malformed event. "PhysicalResourceId" is required: ${JSON.stringify(e)}`));let n=[o.message,`Logs: https://${process.env.AWS_REGION}.console.aws.amazon.com/cloudwatch/home?region=${process.env.AWS_REGION}#logsV2:log-groups/log-group/${encodeURIComponent(process.env.AWS_LAMBDA_LOG_GROUP_NAME)}/log-events/${encodeURIComponent(process.env.AWS_LAMBDA_LOG_STREAM_NAME)}`].join(`
`);await c("FAILED",e,{reason:n})}}}var u=class extends Error{};async function E(t,e){return new Promise((o,n)=>{try{let s=R.request(t,o);s.on("error",n),s.write(e),s.end()}catch(s){n(s)}})}var S=I(import.meta.url),m=S("aws-sdk");m.config.logger=console;var i=new m.S3({region:"us-east-1"}),B=p(async t=>{r("onEventHandler",t);let e=t.RequestType==="Create"?w(t.ResourceProperties.BucketNamePrefix):t.PhysicalResourceId,o;switch(t.RequestType){case"Create":await A(e),o={BucketName:e};break;case"Update":break;case"Delete":await h(e),await C(e);break;default:throw new Error("Unsupported request type")}return c("SUCCESS",{...t,PhysicalResourceId:e,Data:o})});async function A(t){r("createBucket() called with bucketName",t);let e=await i.createBucket({Bucket:t}).promise();r("response",e)}async function C(t){r("deleteBucket() called with bucketName",t);let e=await i.deleteBucket({Bucket:t}).promise();r("response",e)}function w(t){let n="abcdefghijklmnopqrstuvwxyz",s=n.length,a=`${t.toLowerCase().slice(0,63-20-1)}-`;for(let l=0;l<20;l++)a+=n.charAt(Math.floor(Math.random()*s));return a}async function h(t){let e=await i.listObjectVersions({Bucket:t}).promise(),o=[...e.Versions??[],...e.DeleteMarkers??[]];if(o.length===0)return;let n=o.map(s=>({Key:s.Key,VersionId:s.VersionId}));await i.deleteObjects({Bucket:t,Delete:{Objects:n}}).promise(),e?.IsTruncated&&await h(t)}export{B as handler};
