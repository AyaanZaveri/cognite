import { createRequire as topLevelCreateRequire } from 'module';const require = topLevelCreateRequire(import.meta.url);
import{createRequire as f}from"module";function t(o,...e){console.log("[provider-framework]",o,...e.map(s=>typeof s=="object"?JSON.stringify(s,void 0,2):s))}import g from"https";import y from"url";var p="AWSCDK::CustomResourceProviderFramework::CREATE_FAILED",A="AWSCDK::CustomResourceProviderFramework::MISSING_PHYSICAL_ID";async function l(o,e,s={}){let r={Status:o,Reason:s.reason||o,StackId:e.StackId,RequestId:e.RequestId,PhysicalResourceId:e.PhysicalResourceId||A,LogicalResourceId:e.LogicalResourceId,NoEcho:s.noEcho,Data:e.Data};t("submit response to cloudformation",r);let n=JSON.stringify(r),c=y.parse(e.ResponseURL);await I({hostname:c.hostname,path:c.path,method:"PUT",headers:{"content-type":"","content-length":n.length}},n)}function m(o){return async e=>{if(e.RequestType==="Delete"&&e.PhysicalResourceId===p){t("ignoring DELETE event caused by a failed CREATE event"),await l("SUCCESS",e);return}try{await o(e)}catch(s){if(t(s),s instanceof u)throw t("retry requested by handler"),s;e.PhysicalResourceId||(e.RequestType==="Create"?(t("CREATE failed, responding with a marker physical resource id so that the subsequent DELETE will be ignored"),e.PhysicalResourceId=p):t(`ERROR: Malformed event. "PhysicalResourceId" is required: ${JSON.stringify(e)}`));let r=[s.message,`Logs: https://${process.env.AWS_REGION}.console.aws.amazon.com/cloudwatch/home?region=${process.env.AWS_REGION}#logsV2:log-groups/log-group/${encodeURIComponent(process.env.AWS_LAMBDA_LOG_GROUP_NAME)}/log-events/${encodeURIComponent(process.env.AWS_LAMBDA_LOG_STREAM_NAME)}`].join(`
`);await l("FAILED",e,{reason:r})}}}var u=class extends Error{};async function I(o,e){return new Promise((s,r)=>{try{let n=g.request(o,s);n.on("error",r),n.write(e),n.end()}catch(n){r(n)}})}var S=f(import.meta.url),R=S("aws-sdk");R.config.logger=console;var i=new R.Lambda({region:"us-east-1"}),d="live",N=m(async o=>{t("onEventHandler",o);let e,s,r=o.ResourceProperties.FunctionArn,n=r.split(":").pop();switch(o.RequestType){case"Create":{let a=(await w(n)).Version;await C(n,a),e=`${r}:${a}`,s={Version:a};break}case"Update":{e=o.PhysicalResourceId,s={Version:o.PhysicalResourceId.split(":").pop()};break}case"Delete":{await F(n),e=o.PhysicalResourceId;break}default:throw new Error("Unsupported request type")}return l("SUCCESS",{...o,PhysicalResourceId:e,Data:s})});async function w(o){t("createVersion() called with functionName",o);let e=await i.publishVersion({FunctionName:o}).promise();return t("response",e),{Version:e.Version}}async function C(o,e){t("createAlias() called with functionName",o,"version",e);let s;try{t("updateAlias"),s=await i.updateAlias({Name:d,FunctionName:o,FunctionVersion:e}).promise(),t("response",s)}catch(r){if(r.code==="ResourceNotFoundException"&&r.message.startsWith("Alias not found")){t("updateAlias"),s=await i.createAlias({Name:d,FunctionName:o,FunctionVersion:e}).promise(),t("response",s);return}throw r}}async function F(o){t("deleteOldVersions() called with functionName",o);let e;try{e=await i.getAlias({FunctionName:o,Name:d}).promise(),t("getAlias",e);let s=e.FunctionVersion;e=await i.listVersionsByFunction({FunctionName:o,MaxItems:50}).promise(),t("listVersionsByFunction",e);let r=e.Versions||[];for(let n=0,c=r.length;n<c;n++){let a=r[n].Version;if(a===s){t("deleteVersion",a,"skipped");continue}try{t("deleteVersion",a,"do"),e=await i.deleteFunction({FunctionName:o,Qualifier:a}).promise(),t("response",e)}catch(h){t("deleteVersion error",h)}}}catch(s){t("deleteOldVersions error",s)}}export{N as handler};
